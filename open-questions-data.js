let openQuestionsData = [
    {
        question: "Definisci il World Wide Web e descrivi i suoi componenti fondamentali.",
        correctAnswer: "Il World Wide Web (WWW) è un sistema di documenti interconnessi via Internet e accessibili tramite browser web. I suoi componenti fondamentali includono: **Client** (browser web che richiedono risorse), **Server** (macchine che ospitano e servono le risorse), e **Protocolli** (come HTTP, che regolano la comunicazione)."
    },
    {
        question: "Qual è la differenza fondamentale tra URI, URL e URN? Fornisci un esempio concreto per ciascuno.",
        correctAnswer: "Sono tutti identificatori di risorse sul web, ma con scopi diversi: \n- **URI (Uniform Resource Identifier):** È un identificatore generico per qualsiasi risorsa. Es: `urn:isbn:0451450523` (identifica un libro). \n- **URL (Uniform Resource Locator):** È un tipo specifico di URI che fornisce l'ubicazione di una risorsa e il meccanismo per accedervi. Es: `https://www.example.com/pagina.html` (dove si trova la pagina e come accedervi).\n- **URN (Uniform Resource Name):** È un tipo specifico di URI che identifica una risorsa per nome in modo persistente e indipendente dalla sua ubicazione. Es: `urn:ietf:rfc:2141` (identifica uno specifico RFC)."
    },
    {
        question: "Spiega cosa si intende per 'statelessness' del protocollo HTTP. Come viene gestita la necessità di mantenere lo stato utente nelle applicazioni web?",
        correctAnswer: "Il protocollo HTTP è 'stateless' perché ogni richiesta client-server è indipendente dalle precedenti. Il server non mantiene informazioni sullo stato della sessione tra una richiesta e l'altra. Per gestire la necessità di mantenere lo stato utente, si utilizzano meccanismi esterni come: **Cookies** (piccoli file di testo memorizzati nel browser), **Sessioni lato server** (ID sessione inviato via cookie, con dati memorizzati sul server), e **Token** (es. JWT, auto-descrittivi e firmati, usati spesso con API RESTful). L'autenticazione è un prerequisito per l'autorizzazione."
    },
    {
        question: "Qual è la differenza tra un proxy 'forward' e un proxy 'reverse'? Descrivi i casi d'uso tipici per entrambi.",
        correctAnswer: "Sono entrambi server proxy, ma con ruoli opposti: \n- **Forward Proxy:** Si trova tra il client e Internet. Il client lo configura per inoltrare le proprie richieste. Usi tipici: controllo accessi aziendale, caching, anonimato, bypass di filtri.\n- **Reverse Proxy:** Si trova tra Internet e uno o più server web/applicazioni. Le richieste dal client arrivano prima al reverse proxy, che le inoltra ai server interni. Usi tipici: bilanciamento del carico, sicurezza (firewall), caching, terminazione SSL, serving di file statici."
    },
    {
        question: "Illustra il flusso completo di una richiesta web, dalla digitazione di un URL nel browser fino alla visualizzazione della pagina, evidenziando ogni passaggio e i componenti coinvolti.",
        correctAnswer: "1. **Input URL:** L'utente digita l'URL nel browser.\n2. **Risoluzione DNS:** Il browser interroga il DNS per ottenere l'indirizzo IP del server corrispondente all'URL.\n3. **Connessione TCP:** Il browser stabilisce una connessione TCP/IP con l'indirizzo IP del server.\n4. **Richiesta HTTP:** Il browser invia una richiesta HTTP (es. GET) al server.\n5. **Web Server Processing:** Il Web Server (es. Nginx, Apache) riceve la richiesta. Se la risorsa è statica, la serve direttamente. Se dinamica, la inoltra all'Application Server.\n6. **Application Server Processing:** L'Application Server (es. Spring Boot, Node.js) elabora la richiesta, interagisce con il Database (se necessario), genera la risposta dinamica (es. HTML, JSON).\n7. **Risposta HTTP:** L'Application Server restituisce la risposta al Web Server, che a sua volta la invia al browser.\n8. **Rendering del Browser:** Il browser riceve la risposta HTTP, analizza l'HTML, il CSS e il JavaScript, e renderizza la pagina per l'utente."
    },
    {
        question: "Con riferimento a quanto discusso in lezione, definisci e distingui un 'Web Server' da un 'HTTP Server'. Possono essere usati come sinonimi in determinati contesti? Fornisci esempi.",
        correctAnswer: "In molti contesti, specialmente in modo informale, 'Web Server' e 'HTTP Server' sono usati come sinonimi. Tuttavia: \n- **HTTP Server:** Si riferisce specificamente al software che implementa il protocollo HTTP, rispondendo alle richieste HTTP. È il motore che serve le pagine web (statiche o dinamiche tramite moduli/proxy). Esempi: Apache HTTP Server, Nginx.\n- **Web Server:** Ha un significato più ampio. Può riferirsi al software HTTP Server, ma anche all'hardware su cui gira, o più in generale a un sistema che serve contenuti web. A volte include le capacità di un Application Server (es. Tomcat, che è anche un Web Server ma principalmente un Application Server).\nPossono essere sinonimi quando si parla del software che gestisce le richieste HTTP, ma 'Web Server' può anche inglobare il concetto di 'Application Server' se ha capacità di eseguire logica dinamica direttamente (es. Node.js con Express)."
    },
    {
        question: "Spiega la funzione dei codici di stato HTTP. Fornisci un esempio per ciascuna classe di codici (1xx, 2xx, 3xx, 4xx, 5xx).",
        correctAnswer: "I codici di stato HTTP sono codici a tre cifre che indicano l'esito di una richiesta HTTP. Sono raggruppati in classi: \n- **1xx (Informational):** La richiesta è stata ricevuta e il processo continua. Es: `100 Continue`.\n- **2xx (Success):** L'azione richiesta è stata ricevuta, compresa e accettata. Es: `200 OK`, `201 Created`.\n- **3xx (Redirection):** È necessaria un'ulteriore azione per completare la richiesta. Es: `301 Moved Permanently`, `302 Found`.\n- **4xx (Client Error):** La richiesta contiene errori di sintassi o non può essere soddisfatta. Es: `400 Bad Request`, `401 Unauthorized`, `403 Forbidden`, `404 Not Found`.\n- **5xx (Server Error):** Il server ha fallito nel soddisfare una richiesta apparentemente valida. Es: `500 Internal Server Error`, `503 Service Unavailable`."
    },
    {
        question: "Cos'è il Document Object Model (DOM)? Descrivi la sua relazione con HTML e come JavaScript lo utilizza per manipolare la struttura e il contenuto di una pagina.",
        correctAnswer: "Il **DOM (Document Object Model)** è una rappresentazione ad albero degli elementi di una pagina web (HTML o XML). È un'API (Application Programming Interface) che definisce come il browser rappresenta i documenti e come JavaScript può accedervi e modificarli. La relazione con HTML è che il browser costruisce il DOM a partire dalla struttura dell'HTML. JavaScript utilizza il DOM API (es. `document.getElementById()`, `element.innerHTML`, `element.addEventListener()`) per navigare nell'albero, modificare contenuti, stili, attributi e rispondere agli eventi utente, rendendo le pagine interattive e dinamiche."
    },
    {
        question: "Spiega il Box Model di CSS, specificando i suoi componenti e come influenzano il layout degli elementi.",
        correctAnswer: "Il **CSS Box Model** è un modello che incapsula ogni elemento HTML in una scatola rettangolare. I suoi componenti, dall'interno verso l'esterno, sono:\n- **Content:** L'area dove si trova il contenuto reale dell'elemento (testo, immagini, video).\n- **Padding:** Spazio trasparente tra il contenuto e il bordo, serve a dare 'respiro' al contenuto.\n- **Border:** Linea che circonda il padding e il contenuto, ha proprietà di stile, colore e spessore.\n- **Margin:** Spazio trasparente all'esterno del bordo, serve a separare l'elemento dagli altri elementi adiacenti. Ogni componente aggiunge dimensioni all'elemento totale sul layout della pagina."
    },
    {
        question: "Quali sono le differenze principali tra 'var', 'let' e 'const' per la dichiarazione di variabili in JavaScript in termini di scope e riassegnazione?",
        correctAnswer: "Le differenze chiave sono:\n- **`var`:** Ha 'function scope' o 'global scope'. Può essere ridichiarato e riassegnato. È soggetto a 'hoisting' (viene 'sollevato' all'inizio del suo scope, ma non il suo valore iniziale, portando a `undefined` se usato prima della dichiarazione).\n- **`let`:** Introdotto con ES6. Ha 'block scope' (limitato al blocco `{}` in cui è dichiarato). Può essere riassegnato ma non ridichiarato nello stesso scope. Non è soggetto a hoisting in modo utilizzabile (tecnicamente è 'hoisted' ma in una 'temporal dead zone').\n- **`const`:** Introdotto con ES6. Ha 'block scope'. Deve essere inizializzato al momento della dichiarazione e non può essere riassegnato (ma il contenuto di un oggetto/array dichiarato con `const` può essere modificato). Non soggetto a hoisting utilizzabile."
    },
    {
        question: "Descrivi il problema del 'callback hell' in JavaScript. Quali soluzioni moderne sono state introdotte per gestirlo?",
        correctAnswer: "Il 'callback hell' (o 'piramide del doom') si verifica quando si concatenano molte operazioni asincrone nidificando callback su callback, rendendo il codice difficile da leggere, mantenere e debuggare, formando una struttura a 'scalino'. Le soluzioni moderne introdotte in JavaScript sono:\n- **Promises:** Rappresentano il risultato finale di un'operazione asincrona. Permettono di concatenare operazioni con `.then()` per il successo e `.catch()` per gli errori, appiattendo la struttura del codice.\n- **Async/Await:** Una sintassi 'syntactic sugar' costruita sulle Promises, che permette di scrivere codice asincrono con una sintassi simile a quella sincrona, rendendolo ancora più leggibile. `await` 'mette in pausa' l'esecuzione della funzione `async` finché la Promise non si risolve."
    },
    {
        question: "Illustra in dettaglio il funzionamento dell'Event Loop in JavaScript. Descrivi il ruolo della Call Stack, delle Web APIs, della Callback Queue e della Microtask Queue.",
        correctAnswer: "L'**Event Loop** è il meccanismo che permette a JavaScript (che è single-threaded) di gestire operazioni asincrone e non bloccanti. Le sue componenti:\n- **Call Stack:** Struttura dati LIFO che esegue il codice JavaScript sincrono. Ogni funzione chiamata viene pushata nello stack e poppata quando termina.\n- **Web APIs (o Browser APIs/Node.js APIs):** Funzionalità non-JavaScript (es. `setTimeout`, `fetch`, DOM events) fornite dall'ambiente host (browser/Node.js). Quando una funzione API viene chiamata, viene passata a queste API che la gestiscono in background.\n- **Callback Queue (o Task Queue/Macrotask Queue):** Qui vengono messe le callback delle Web APIs una volta completate le loro operazioni asincrone (es. il timeout di `setTimeout` scade, il click di un bottone avviene).\n- **Microtask Queue:** Ha priorità più alta della Callback Queue. Contiene callback di Promises (`.then()`, `.catch()`, `.finally()`) e `queueMicrotask()`.\n- **Event Loop (il meccanismo):** Monitora costantemente la Call Stack e le Queue. Se la Call Stack è vuota, sposta le funzioni dalla Microtask Queue alla Call Stack. Una volta vuota anche la Microtask Queue, sposta le funzioni dalla Callback Queue alla Call Stack. Questo ciclo continuo assicura che il codice asincrono venga eseguito quando la Call Stack è libera."
    },
    {
        question: "Spiega il contesto del 'this' in JavaScript. Come cambia il suo valore in base a come una funzione viene invocata e come le Arrow Function modificano questo comportamento?",
        correctAnswer: "Il valore di `this` in JavaScript è determinato da come la funzione viene invocata, non da dove viene definita (con l'eccezione delle arrow functions). I contesti principali sono:\n- **Global Context:** Se non dentro una funzione, `this` si riferisce all'oggetto globale (`window` nel browser, `global` in Node.js).\n- **Method Call:** Se una funzione è un metodo di un oggetto, `this` si riferisce all'oggetto stesso.\n- **Constructor Call:** Se una funzione è chiamata con `new`, `this` si riferisce alla nuova istanza dell'oggetto creata.\n- **Explicit Binding:** Con `call()`, `apply()`, `bind()`, si può impostare esplicitamente il valore di `this`.\n- **Event Handler:** `this` si riferisce all'elemento su cui è scattato l'evento.\n\nLe **Arrow Functions** sono una 'eccezione' al comportamento di `this`: non definiscono un proprio `this` ma lo ereditano lessicalmente dal contesto in cui sono state definite (il loro scope genitore). Questo le rende particolarmente utili in callback o metodi dove si vuole mantenere il contesto del `this` dell'ambiente circostante, evitando l'uso di `bind()` o di variabili come `that = this`."
    },
    {
        question: "Spiega l'obiettivo principale di TypeScript e perché è stato sviluppato come 'superset' di JavaScript. Qual è il beneficio chiave della 'tipizzazione statica' offerta da TypeScript?",
        correctAnswer: "TypeScript è un superset tipizzato di JavaScript che compila in JavaScript puro. Il suo obiettivo principale è aggiungere la **tipizzazione statica opzionale** a JavaScript, permettendo di rilevare errori di tipo in fase di sviluppo (prima dell'esecuzione). Essere un 'superset' significa che ogni codice JavaScript valido è anche codice TypeScript valido. Il beneficio chiave della tipizzazione statica è una maggiore **robustezza del codice**, migliore **manutenibilità** (specialmente in progetti grandi), **refactoring più sicuro**, **migliore documentazione** implicita e un'esperienza di sviluppo superiore con **autocompletamento** e 'intellisense' negli IDE."
    },
    {
        question: "Immagina di dover convincere un team di sviluppatori JavaScript ad adottare TypeScript. Quali sono i tre punti chiave che evidenzieresti, supportandoli con esempi di codice?",
        correctAnswer: "Tre punti chiave per convincere:\n1.  **Rilevamento Errori Precoce:** TypeScript cattura errori di tipo durante la compilazione, non a runtime. \n    ```javascript\n    // JS: Errore a runtime\n    function greet(name) { return 'Hello ' + name.toUpperCase(); }\n    greet(123); // OK in JS, errore a runtime\n    // TS: Errore in fase di compilazione\n    function greetTs(name: string): string { return 'Hello ' + name.toUpperCase(); }\n    greetTs(123); // Errore di tipo: Argument of type 'number' is not assignable to parameter of type 'string'.\n    ```\n2.  **Migliore Manutenibilità e Leggibilità:** I tipi espliciti rendono il codice più facile da comprendere e mantenere, fungendo da documentazione intrinseca.\n    ```typescript\n    interface User { id: number; name: string; email?: string; }\n    function printUserDetails(user: User) { /* ... */ }\n    // Si capisce subito la struttura dell'oggetto 'user' atteso.\n    ```\n3.  **Supporto IDE Potenziato:** Migliora drasticamente l'autocompletamento, il refactoring, la navigazione del codice e la segnalazione degli errori direttamente nell'editor.\n    (Non facilmente rappresentabile con codice, ma si spiegherebbe l'esperienza con 'IntelliSense' che suggerisce proprietà e metodi validi basati sui tipi definiti)."
    },
    {
        question: "Descrivi il processo di compilazione di TypeScript. Cosa produce il compilatore TypeScript e perché è necessario questo passaggio?",
        correctAnswer: "Il processo di compilazione di TypeScript avviene tramite il compilatore `tsc` (TypeScript Compiler). Quando si esegue `tsc` su un file `.ts`, il compilatore:\n1.  **Analizza il codice:** Verifica la correttezza della sintassi e dei tipi (controllo statico dei tipi).\n2.  **Transpila:** Converte il codice TypeScript (che può contenere funzionalità ES6+ e tipi) in codice JavaScript puro (solitamente ES5 o ES6, a seconda della configurazione `target` nel `tsconfig.json`).\nIl compilatore produce file `.js` (e opzionalmente file `.map` per il debugging). Questo passaggio è necessario perché i browser (o Node.js) non possono eseguire direttamente codice TypeScript. Possono eseguire solo codice JavaScript. Quindi, TypeScript funge da linguaggio di sviluppo che offre benefici come la tipizzazione statica, ma il codice deve essere 'tradotto' in JavaScript per essere eseguibile nell'ambiente di runtime."
    },
    {
        question: "Qual è la differenza concettuale e pratica tra un 'type' e un' 'interface' in TypeScript? Quando è più appropriato usare l'uno o l'altro?",
        correctAnswer: "Sia `type` che `interface` servono a definire la forma degli oggetti in TypeScript, ma con alcune differenze:\n- **`interface`:** Progettata per 'descrivere la forma degli oggetti'. Supporta 'declaration merging' (possono essere aperte e aggiunte nuove proprietà in più dichiarazioni con lo stesso nome). Sono estensibili tramite `extends` e implementabili da classi tramite `implements`. Sono concettualmente più vicine alla programmazione orientata agli oggetti.\n- **`type` (Type Aliases):** Può definire alias per qualsiasi tipo (primitivi, unioni, intersezioni, tuple, ecc.), non solo oggetti. Non supporta 'declaration merging'. Possono essere estesi/combinati usando 'intersection types' (`&`).\n\n**Quando usare:**\n- Preferire **`interface`** per definire la forma di oggetti pubblici/API, classi, o per definire contratti chiari, specialmente se si prevede che la definizione possa essere estesa o implementata.\n- Preferire **`type`** per alias di tipi primitivi, union types, tuple, o per definizioni di tipi più complesse e non-oggettuali. Anche quando non si vuole il 'declaration merging'."
    },
    {
        question: "Spiega il concetto di 'Write Once, Run Anywhere' (WORA) in relazione a Java e alla Java Virtual Machine (JVM).",
        correctAnswer: "Il concetto di **'Write Once, Run Anywhere' (WORA)** è un principio fondamentale di Java. Significa che il codice Java, una volta scritto e compilato in bytecode, può essere eseguito su qualsiasi piattaforma che abbia una **Java Virtual Machine (JVM)** installata, senza bisogno di ricompilazione specifica per quell'ambiente. La JVM agisce come un livello di astrazione tra il codice Java compilato (bytecode) e l'hardware/sistema operativo sottostante, traducendo il bytecode in istruzioni native della macchina. Questo garantisce la portabilità del codice Java su diversi sistemi operativi e architetture hardware."
    },
    {
        question: "Approfondisci la distinzione tra Spring Framework e Spring Boot. Qual è il problema principale che Spring Boot si propone di risolvere e come lo fa?",
        correctAnswer: "La distinzione è la seguente:\n- **Spring Framework:** È un framework completo e modulare per lo sviluppo di applicazioni Java. Fornisce un'ampia gamma di funzionalità (es. IoC/DI, AOP, transazioni, MVC) ma richiede una configurazione estesa (XML o Java-based).\n- **Spring Boot:** È un'estensione di Spring Framework che semplifica e velocizza lo sviluppo di applicazioni Spring, specialmente microservizi, riducendo drasticamente la configurazione boilerplate.\n\nIl problema principale che Spring Boot risolve è la **complessità e la verbosità della configurazione** del tradizionale Spring Framework, specialmente per applicazioni standalone e microservizi. Lo fa attraverso:\n- **Autoconfigurazione:** Spring Boot tenta di configurare automaticamente la tua applicazione Spring in base alle dipendenze che hai aggiunto al classpath (es. se trova H2, configura un DataSource in-memory).\n- **Starter Dependencies:** Fornisce 'starter' che raggruppano dipendenze comuni e le loro configurazioni predefinite, riducendo il numero di dipendenze che devi gestire manualmente (es. `spring-boot-starter-web` include Tomcat, Spring MVC, Jackson).\n- **Embedded Servers:** Permette di eseguire applicazioni come file JAR eseguibili che includono un server web embedded (Tomcat, Jetty, Undertow), eliminando la necessità di deploy su un application server esterno."
    },
    {
        question: "Spiega i concetti di Inversion of Control (IoC) e Dependency Injection (DI) nel contesto di Spring. Perché sono principi fondamentali?",
        correctAnswer: "- **Inversion of Control (IoC):** È un principio di progettazione in cui il controllo del flusso di un programma (o di parte di esso) è invertito rispetto al controllo tradizionale. Invece che essere il codice applicativo a creare e gestire le dipendenze, è il framework (Spring IoC Container) che si occupa di crearle e iniettarle. Risponde alla domanda: 'Chi si occupa di gestire gli oggetti e le loro dipendenze?'\n- **Dependency Injection (DI):** È un pattern di implementazione specifico del principio IoC. Consiste nell'iniettare le dipendenze (oggetti richiesti da un'altra classe per funzionare) in una classe dall'esterno, invece che far sì che la classe le crei al proprio interno. In Spring, questo avviene tramite costruttori, setter o field injection (`@Autowired`).\n\nSono fondamentali perché promuovono:\n- **Accoppiamento Lasco (Loose Coupling):** Le classi dipendono da interfacce o astrazioni, non da implementazioni concrete, rendendole più flessibili.\n- **Testabilità:** Le dipendenze possono essere facilmente 'mockate' o sostituite per i test unitari.\n- **Manutenibilità:** Cambiare un'implementazione di una dipendenza non richiede modifiche alla classe che la usa.\n- **Modularità e Riutilizzo:** Componenti indipendenti sono più facili da riutilizzare in contesti diversi."
    },
    {
        question: "Qual è la differenza fondamentale tra `@Controller` e `@RestController` in Spring MVC? Quando si usa l'una e quando l'altra?",
        correctAnswer: "Entrambe sono annotazioni di Spring per definire classi che gestiscono richieste web, ma con una differenza chiave:\n- **`@Controller`:** Usata per le classi che gestiscono le richieste HTTP e ritornano un nome di vista (es. un file JSP, Thymeleaf). È tipica delle applicazioni web tradizionali che rendono pagine HTML lato server. Spesso usata in combinazione con `@ResponseBody` sui singoli metodi se un metodo deve ritornare dati anziché una vista.\n- **`@RestController`:** È una scorciatoia che combina `@Controller` e `@@ResponseBody`. Significa che ogni metodo all'interno di questa classe assumerà che il valore di ritorno debba essere direttamente serializzato nel corpo della risposta HTTP (es. JSON, XML), anziché essere interpretato come un nome di vista. È la scelta preferita per costruire **API RESTful** dove il client si aspetta dati, non pagine HTML. Si usa `@RestController` per i servizi web e `@Controller` per le applicazioni web 'tradizionali' con rendering di view."
    },
    {
        question: "Spiega il ciclo di vita di una richiesta in un'applicazione Spring Boot MVC/REST, dal momento in cui arriva al server fino alla generazione della risposta, evidenziando il ruolo di DispatcherServlet, Controller, Service e Repository.",
        correctAnswer: "Il ciclo di vita di una richiesta in Spring Boot:\n1.  **Arrivo della Richiesta:** Una richiesta HTTP (es. da un browser o client API) arriva all'**Embedded Server** (es. Tomcat) integrato in Spring Boot.\n2.  **DispatcherServlet:** Il server inoltra la richiesta al **`DispatcherServlet`** di Spring, che funge da 'front controller'. È il punto di ingresso centrale per tutte le richieste web Spring.\n3.  **Handler Mapping:** Il `DispatcherServlet` consulta gli 'Handler Mappings' (es. basati su `@RequestMapping`, `@GetMapping`) per trovare il **Controller** appropriato che può gestire l'URL e il metodo HTTP della richiesta.\n4.  **Invocazione del Controller:** Il `DispatcherServlet` invoca il metodo nel **Controller** corrispondente (es. un metodo annotato con `@GetMapping`). Il Controller si occupa di gestire la logica di alto livello della richiesta e di solito delega la logica di business a un livello di **Service**.\n5.  **Business Logic (Service Layer):** Il Service Layer (annotato con `@Service`) contiene la logica di business principale dell'applicazione. Riceve dati dal Controller, li elabora, e spesso interagisce con il livello di persistenza per accedere o modificare i dati.\n6.  **Data Access (Repository Layer):** Il Repository Layer (annotato con `@Repository`) è responsabile dell'interazione con il database. Utilizza Spring Data JPA per eseguire operazioni CRUD (Create, Read, Update, Delete) sui dati, recuperando o salvando le entità.\n7.  **Generazione della Risposta:** I dati vengono restituiti dal Repository al Service, dal Service al Controller. Se è un `@RestController`, il Controller serializza i dati (es. in JSON) e li invia come corpo della risposta HTTP. Se è un `@Controller`, potrebbe risolvere una vista e popolare un modello.\n8.  **Invio della Risposta:** La risposta finale (HTML, JSON, ecc.) viene inviata dal `DispatcherServlet` al client tramite l'Embedded Server."
    },
    {
        question: "Spiega il concetto di Object-Relational Mapping (ORM) e il problema che si propone di risolvere.",
        correctAnswer: "**Object-Relational Mapping (ORM)** è una tecnica di programmazione che mappa i dati da un sistema di database relazionale a un modello di oggetti di un linguaggio di programmazione orientato agli oggetti (es. Java). Il problema che si propone di risolvere è la 'mismatch impedence' tra il paradigma relazionale (tabelle, righe, colonne) e il paradigma orientato agli oggetti (oggetti, classi, eredità). L'ORM permette agli sviluppatori di interagire con il database utilizzando oggetti del loro linguaggio, senza dover scrivere direttamente query SQL o gestire la conversione dei tipi, semplificando e velocizzando lo sviluppo dell'accesso ai dati."
    },
    {
        question: "Qual è la relazione tra JPA (Java Persistence API), Hibernate e Spring Data JPA? Qual è il ruolo di ciascuno?",
        correctAnswer: "Sono strati di astrazione per la persistenza in Java:\n- **JPA (Java Persistence API):** È una **specifica** Java standard (un insieme di interfacce e annotazioni) per la persistenza di oggetti Java in database relazionali. Definisce 'cosa' fare, non 'come' implementarlo.\n- **Hibernate:** È una delle **implementazioni** più popolari e complete della specifica JPA. È il framework ORM che esegue effettivamente il mapping degli oggetti alle tabelle e genera le query SQL.\n- **Spring Data JPA:** È un progetto all'interno del più ampio ecosistema Spring. Non è un'implementazione di JPA, ma un **livello di astrazione e semplificazione** costruito sopra JPA (e quindi sopra Hibernate). Rende molto più facile lavorare con JPA fornendo interfacce repository e generando automaticamente le implementazioni dei metodi CRUD e delle query basate sul nome del metodo, riducendo notevolmente il codice boilerplate che altrimenti si dovrebbe scrivere con JPA/Hibernate puro."
    },
    {
        question: "Descrivi in dettaglio il ruolo dell'annotazione `@Entity`. Quali requisiti deve soddisfare una classe per essere un'entità JPA? Fornisci un esempio.",
        correctAnswer: "L'annotazione `@Entity` (del package `jakarta.persistence` o `javax.persistence` per versioni precedenti) marca una classe Java come un'entità persistente. Questo significa che le istanze di questa classe possono essere mappate a righe di una tabella del database. La classe diventa un'oggetto che rappresenta una riga della tabella e i suoi campi rappresentano le colonne.\n\n**Requisiti per una classe `@Entity`:**\n1.  Deve avere un **costruttore pubblico o protetto senza argomenti** (default constructor).\n2.  Deve avere una **chiave primaria** unica, identificata dall'annotazione `@Id` su uno dei suoi campi.\n3.  Non deve essere `final` e non deve avere metodi `final` o campi persistenti `final`.\n\n**Esempio:**\n```java\nimport jakarta.persistence.*;\n\n@Entity\n@Table(name = \"prodotti\") // Opzionale: per specificare il nome della tabella\npublic class Prodotto {\n    @Id // Marca come chiave primaria\n    @GeneratedValue(strategy = GenerationType.IDENTITY) // Generazione automatica dell'ID\n    private Long id;\n    \n    @Column(name = \"nome_prodotto\", nullable = false) // Opzionale: per personalizzare colonna\n    private String nome;\n    private double prezzo;\n\n    // Costruttore senza argomenti (necessario per JPA)\n    public Prodotto() {}\n\n    // Costruttore con argomenti (facoltativo, ma utile)\n    public Prodotto(String nome, double prezzo) {\n        this.nome = nome;\n        this.prezzo = prezzo;\n    }\n\n    // Getter e Setter\n    public Long getId() { return id; }\n    public void setId(Long id) { this.id = id; }\n    public String getNome() { return nome; }\n    public void setNome(String nome) { this.nome = nome; }\n    public double getPrezzo() { return prezzo; }\n    public void setPrezzo(double prezzo) { this.prezzo = prezzo; }\n}\n```"
    },
    {
        question: "Spiega in dettaglio il ruolo dell'annotazione `@Repository` e come Spring Data JPA ne sfrutta il potenziale per generare automaticamente l'implementazione dei metodi.",
        correctAnswer: "L'annotazione `@Repository` (di Spring Framework) è una specializzazione di `@Component` che indica che una classe (o, più comunemente, un'interfaccia in Spring Data JPA) è un 'repository' per l'accesso ai dati. Il suo ruolo principale è quello di fungere da **marcatore per la scoperta dei componenti** da parte di Spring (per la Dependency Injection) e per la **traduzione delle eccezioni di persistenza** specifiche del database in eccezioni generiche di Spring `DataAccessException`.\n\n**Come Spring Data JPA ne sfrutta il potenziale:**\nQuando un'interfaccia estende una delle interfacce di Spring Data JPA (es. `CrudRepository`, `PagingAndSortingRepository`, `JpaRepository`), Spring Data JPA, al momento dell'avvio dell'applicazione, rileva questa interfaccia annotata con `@Repository` (o comunque individuata nel package scanning) e **genera automaticamente a runtime un'implementazione concreta** di quella interfaccia. Questa implementazione contiene i metodi CRUD (Create, Read, Update, Delete) e anche i metodi per le query personalizzate che seguono le convenzioni di naming di Spring Data JPA (es. `findByNome()`, `findByPrezzoGreaterThan()`). Questo elimina la necessità per lo sviluppatore di scrivere manualmente tutto il codice boilerplate per le operazioni di accesso ai dati."
    },
    {
        question: "Come si definiscono query personalizzate in Spring Data JPA basate sul nome del metodo? Fai almeno due esempi.",
        correctAnswer: "Spring Data JPA permette di definire query personalizzate semplicemente dichiarando un metodo nell'interfaccia del repository, seguendo una convenzione di naming specifica. Spring Data JPA 'analizza' il nome del metodo e genera automaticamente la query SQL/JPQL corrispondente. La struttura generale è `findBy[NomeCampo][Operatore][AND/OR][AltroCampo]...`.\n\n**Esempi:**\n\n**1. Trova prodotti per nome:**\n```java\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport java.util.List;\n\npublic interface ProdottoRepository extends JpaRepository<Prodotto, Long> {\n    // Trova tutti i prodotti con un determinato nome\n    List<Prodotto> findByNome(String nome);\n}\n```\n\n**2. Trova prodotti per prezzo inferiore a un certo valore e ordinati per nome:**\n```java\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport java.util.List;\n\npublic interface ProdottoRepository extends JpaRepository<Prodotto, Long> {\n    // Trova prodotti con prezzo inferiore a 'prezzoMassimo', ordinati alfabeticamente per nome\n    List<Prodotto> findByPrezzoLessThanOrderByNomeAsc(double prezzoMassimo);\n}\n```\n\nAltri esempi di operatori comuni: `GreaterThan`, `LessThanEqual`, `Between`, `Like`, `StartingWith`, `EndingWith`, `Containing`, `IsNull`, `IsNotNull`, `True`, `False`, `And`, `Or`, `Not`."
    },
    {
        question: "Che differenza c'è tra autenticazione e autorizzazione in un'applicazione web?",
        correctAnswer: "Sono due concetti distinti ma correlati nel controllo degli accessi: **Autenticazione** è il processo di verificare l'identità di un utente o di un sistema. Risponde alla domanda 'Sei chi dici di essere?' e tipicamente avviene tramite credenziali (username/password), token, biometria, ecc.. **Autorizzazione** è il processo di determinare a quali risorse, funzioni o azioni un utente (già autenticato) ha permesso di accedere o eseguire. Risponde alla domanda 'Cosa ti è permesso fare?' e si basa su ruoli, permessi o policy assegnati all'utente. L'autenticazione precede sempre l'autorizzazione."
    },
    {
        question: "Descrivi una versione semplificata (e non sicura) di 'Basic Auth' come presentata nelle slide per una richiesta HTTP. Quali miglioramenti si possono apportare per renderla 'un poco più sicura'?",
        correctAnswer: "Una versione semplificata e non sicura di Basic Auth prevede l'invio di username e password **in chiaro come query parameters** nella richiesta HTTP (es. `GET /risorsa?user=admin&pass=123`). Questo è estremamente insicuro perché le credenziali sono esposte nell'URL e nei log.\nPer renderla 'un poco più sicura' si possono apportare due miglioramenti chiave:\n1.  Utilizzare il metodo **POST** anziché GET: le credenziali vengono inviate nel **body della richiesta**, che è meno visibile dell'URL.\n2.  Utilizzare il protocollo **HTTPS** anziché HTTP standard: questo cripta l'intera comunicazione (inclusi gli header e il body della richiesta), proteggendo le credenziali e i dati da intercettazioni."
    },
    {
        question: "In un sistema di autenticazione basato su sessione, come si distingue un utente autenticato da uno non autenticato secondo il modello discusso a lezione? Come un filtro server-side dovrebbe gestire le richieste?",
        correctAnswer: "Secondo il modello discusso, un utente autenticato viene distinto da uno non autenticato tramite la presenza di un **attributo (ad esempio lo username)** salvato nella sessione utente lato server. Quando un utente si autentica con successo, il server imposta questo attributo nella sessione.\nUn **filtro server-side** (o 'middleware'/'Interceptor') dovrebbe:\n1.  **Verificare la Sessione:** Per ogni generica richiesta HTTP, il filtro deve verificare se la sessione corrente contiene l'attributo che indica l'autenticazione.\n2.  **Accesso Consentito:** Se l'attributo è presente, la richiesta viene fatta passare al handler appropriato.\n3.  **Accesso Negato:** Se l'attributo non è presente, il filtro risponde con un **codice di stato 401 UNAUTHORIZED**, bloccando l'accesso alla risorsa protetta."
    },
    {
        question: "Qual è il trattamento speciale che riceve una richiesta di login in un sistema di autenticazione basato su sessione? Descrivi il flusso al livello di 'request handler' e 'service'.",
        correctAnswer: "La richiesta di login (`/login`) riceve un trattamento speciale: **deve essere fatta passare in ogni caso** dal filtro di autenticazione, anche se l'utente non è ancora autenticato, altrimenti non potrebbe mai autenticarsi.\nIl flusso al livello di 'request handler' e 'service' è il seguente:\n1.  **Request Handler (Controller):** Riceve la richiesta di login (es. `POST /login` con username e password nel body).\n2.  **Service Layer:** Il Request Handler delega a un opportuno `@Service` (es. `AuthService`) il compito di verificare le credenziali (username e password) fornite dall'utente. Questo servizio potrebbe interagire con un database per recuperare e confrontare le credenziali.\n3.  **Risultato Verifica:**\n    * **Credenziali Corrette:** Se la verifica ha successo, il Service comunica al Controller la validità. Il Controller a sua volta **crea nella sessione l'attributo** (es. `session.setAttribute('username', user.getUsername())`) che 'segnala' la corretta autenticazione dell'utente. La risposta sarà tipicamente un `200 OK` o un redirect.\n    * **Credenziali Errate:** Se la verifica fallisce, il Service lo comunica. Il Controller risponde anche in questo caso con un codice **401 UNAUTHORIZED** (o `403 Forbidden` a seconda delle convenzioni), indicando che le credenziali non sono valide."
    },
    {
        question: "Come può essere realizzata una richiesta di logout in un sistema basato su sessione? Quale meccanismo server-side è coinvolto?",
        correctAnswer: "Una richiesta di logout può essere realizzata in modo semplice **invalidando la sessione** lato server. Quando l'utente richiede il logout (es. cliccando un bottone 'Logout' che invia una richiesta a `/logout`):\n1.  Il server riceve la richiesta.\n2.  Il request handler (o un filtro/interceptor specifico per il logout) invoca un metodo sulla sessione HTTP (es. `HttpSession.invalidate()`).\nQuesto meccanismo elimina tutti gli attributi associati a quella sessione dal server, incluso l'attributo che segnalava l'autenticazione dell'utente. In questo modo, le richieste successive da parte di quel client non saranno più associate a una sessione autenticata e verranno bloccate dal filtro, richiedendo una nuova autenticazione."
    },
    {
        question: "Perché il server dovrebbe esporre una 'route' accessibile anche a utenti non autenticati che permetta all'applicazione client-side di verificare lo stato corrente dell'autenticazione?",
        correctAnswer: "Il server dovrebbe esporre una route (es. `/api/auth/status` o `/api/me`) accessibile anche a utenti non autenticati per permettere all'applicazione client-side (es. un'applicazione Single Page Application SPA o un'interfaccia utente basata su framework come React/Angular/Vue) di **verificare in qualsiasi momento lo stato corrente dell'autenticazione** dell'utente.\n\nQuesto è utile per:\n1.  **Rendering Condizionale dell'UI:** La parte client-side può decidere se mostrare elementi come 'Login'/'Registrati' o 'Profilo Utente'/'Logout' al caricamento della pagina o dopo un'operazione, senza dover fare un redirect o un tentativo di accesso fallito.\n2.  **Esperienza Utente Migliorata:** Evita di presentare all'utente contenuti o funzionalità non disponibili, o di reindirizzarlo inutilmente alla pagina di login. Permette all'interfaccia di reagire dinamicamente allo stato di autenticazione.\n3.  **Gestione della Sessione al Caricamento:** Al caricamento iniziale dell'applicazione client-side, questa route può essere interrogata per determinare se una sessione utente è già attiva (es. per un cookie di sessione persistente), permettendo di ripristinare lo stato autenticato senza richiedere un nuovo login."
    },
    {
        question: "Cosa si intende per Jakarta Enterprise Edition (Jakarta EE) e Jakarta Web Profile? Qual è il loro ruolo nello sviluppo di applicazioni web?",
        correctAnswer: "Jakarta Enterprise Edition (Jakarta EE), precedentemente nota come Java Enterprise Edition (Java EE), è un insieme di specifiche che estendono Java con librerie, componenti e API per lo sviluppo di applicazioni commerciali, non incluse nel JDK standard. Jakarta Web Profile è un sottoinsieme di queste specifiche e librerie, specificamente orientato allo sviluppo di applicazioni web. Il loro ruolo è fornire un ambiente standardizzato e un set di API per creare applicazioni server-side Java robuste e scalabili, gestite da un Web Container (come Tomcat) che implementa queste specifiche. "
    },
    {
        question: "Descrivi il rapporto tra un Server HTTP (es. Apache Tomcat), il Web Container e le applicazioni Java/Jakarta. Chi incapsula chi in questa architettura?",
        correctAnswer: "In questa architettura, il Server HTTP (es. Apache Tomcat) esiste come applicativo indipendente e **incapsula** una o più applicazioni Java/Jakarta. Tomcat implementa la specifica Jakarta Web Profile e al suo interno risiede il **Web Container**. Il Web Container agisce come interfaccia tra il Server HTTP e le applicazioni, implementando la specifica Jakarta Web Profile e gestendo il ciclo di vita delle Servlet che compongono l'applicazione. Il Server HTTP riceve le richieste e, in base al pathname, le inoltra al Web Container se destinate a una delle app. "
    },
    {
        question: "Quali sono i due strumenti principali offerti da Jakarta Web Profile per lo sviluppo di applicazioni web, e qual è la loro funzione?",
        correctAnswer: "Jakarta Web Profile offre principalmente due strumenti:\n1.  **Servlet:** Sono oggetti i cui metodi ricevono richieste HTTP, elaborano la risorsa richiesta e la inviano in risposta. Lo sviluppatore crea classi-Servlet che vengono istanziate da Tomcat all'avvio dell'applicazione. Ogni Servlet può specificare le route a cui risponde, e Tomcat inoltra le richieste opportune. \n2.  **JSP (Jakarta Server Pages):** Sono pagine scritte in un linguaggio che intreccia HTML e frammenti di codice Java. A ciascuna JSP Jakarta abbina una propria Servlet che genera una pagina HTML da inviare al client usando il contenuto della JSP. "
    },
    {
        question: "Descrivi la gerarchia delle classi e interfacce principali dell'API Servlet e i metodi fondamentali che il Web Container utilizza per gestire il ciclo di vita di una Servlet.",
        correctAnswer: "La gerarchia delle classi e interfacce principali dell'API Servlet è la seguente: \n* **Interfaccia `Servlet`:** Alla base della gerarchia, definisce i metodi che ogni Servlet deve possedere per essere gestita dal Web Container:\n    * `init(ServletConfig config)`: Invocato dal Web Container per inizializzare la Servlet dopo la creazione dell'oggetto. \n    * `service(ServletRequest req, ServletResponse res)`: Invocato dal Web Container quando la Servlet deve gestire una richiesta e fornire una risposta. \n    * `destroy()`: Invocato dal Web Container per permettere alla Servlet di 'fare pulizia' prima di essere chiusa. \n* **Classe Astratta `GenericServlet`:** Implementa l'interfaccia `Servlet` fornendo un'implementazione di base per `init(ServletConfig config)` (memorizza l'oggetto config e chiama un `init()` senza parametri che può essere ridefinito dalle sottoclassi). \n* **Classe `HttpServlet`:** Estende `GenericServlet` e implementa funzionalità di base per Servlet dedicate a richieste HTTP. In particolare, implementa il metodo `service` per distinguere i metodi HTTP (GET, POST, ecc.) e invoca metodi specifici come `doGet(req, res)`, `doPost(req, res)`, che devono essere implementati dalle sottoclassi della Servlet. "
    },
    {
        question: "Spiega le tre fasi principali (START, SERVICE, STOP) del ciclo di vita di una Servlet e cosa avviene in ciascuna di esse dal punto di vista del Web Container.",
        correctAnswer: "Il ciclo di vita di una Servlet si compone di tre momenti principali, gestiti dal Web Container: \n1.  **START:** Inizia all'installazione dell'applicazione o all'avvio del Web Server.\n    * **Creazione:** Il Web Container crea un `ServletContext` (comune all'applicazione), una singola istanza per ciascuna Servlet e un `ServletConfig` per ogni Servlet (contenente parametri di configurazione e riferimento al `ServletContext`). \n    * **Inizializzazione:** Per ogni Servlet, il Web Container chiama `sN.init(cfN)`, che a sua volta invoca `sN.init()`. La Servlet è considerata attiva solo dopo il completamento di `init()`. \n2.  **SERVICE:** La Servlet è attiva e pronta a ricevere richieste.\n    * **Matching & Routing:** Il Web Container confronta l'URL della richiesta con gli `urlPatterns` dichiarati dalle Servlet per determinare la Servlet 'vincente'. Se non c'è matching, risponde con un 404 Not Found. \n    * **Predisposizione:** Vengono creati gli oggetti `HttpServletRequest` e `HttpServletResponse` a partire dagli oggetti `ServletRequest/Response` di partenza. \n    * **Invocazione del Servizio:** Viene invocato `s.service(req, res)` (di `HttpServlet`), che a sua volta invocherà il metodo `s.doXXX` appropriato (es. `doGet`, `doPost`) in base al metodo HTTP della richiesta. \n3.  **STOP:** Si verifica allo spegnimento del Web Server o alla disinstallazione dell'applicazione.\n    * **Cleaning up:** Per ogni Servlet, il Web Container chiama il metodo `sN.destroy()`, che permette alla Servlet di rilasciare risorse (es. chiudere connessioni DB). \n    * **Garbage Collection:** Gli oggetti Servlet, `ServletConfig` e `ServletContext` vengono eliminati. "
    },
    {
        question: "Quali sono i componenti principali di un URL (protocollo, host, porta, path, query string, fragment)? Fai un esempio di URL e identifica ogni componente.",
        correctAnswer: "I componenti principali di un URL sono:\n- **Protocollo:** Il metodo di accesso alla risorsa (es. `http`, `https`).\n- **Host/Dominio:** Il nome del server dove si trova la risorsa (es. `www.example.com`).\n- **Porta:** Il numero di porta del server (spesso omessa se standard, es. 80 per HTTP, 443 per HTTPS). Es: `:8080`.\n- **Path:** Il percorso della risorsa sul server (es. `/prodotti/elettronica`).\n- **Query String:** Una serie di coppie chiave-valore per passare parametri al server, iniziata da `?` e separate da `&` (es. `?categoria=smartphone&prezzo_max=500`).\n- **Fragment:** Un identificatore per una sezione specifica all'interno della risorsa, iniziato da `#` (es. `#sezione3`).\n\n**Esempio:** `https://www.example.com:8080/catalogo/prodotti.html?id=123&colore=rosso#specifiche`\n- Protocollo: `https`\n- Host: `www.example.com`\n- Porta: `8080`\n- Path: `/catalogo/prodotti.html`\n- Query String: `?id=123&colore=rosso`\n- Fragment: `#specifiche`"
    },
    {
        question: "Spiega il concetto di 'origine' (origin) nel contesto della sicurezza web (es. Same-Origin Policy) e come è determinata da un URL.",
        correctAnswer: "L'**Origine** (Origin) è un concetto di sicurezza fondamentale nel web, utilizzato principalmente dalla Same-Origin Policy (SOP). L'origine di un documento o di uno script è definita dalla combinazione di **protocollo**, **host (dominio)** e **porta** del suo URL. Due URL hanno la stessa origine solo se tutti e tre questi componenti sono identici. La Same-Origin Policy è un meccanismo di sicurezza critico che impedisce a uno script caricato da una sorgente di interagire con le risorse di un'altra sorgente (es. fare richieste HTTP, accedere al DOM o ai cookie), a meno che non ci siano specifiche eccezioni (es. CORS). Questo previene attacchi come il cross-site scripting (XSS) e il cross-site request forgery (CSRF)."
    },
    {
        question: "Distingui tra pagine web statiche e dinamiche. Quali sono le implicazioni principali per lo sviluppo e l'interazione utente?",
        correctAnswer: "**Pagine Web Statiche:** Sono file (es. HTML, CSS, immagini) predefiniti e immutabili memorizzati su un server. Ogni utente che le richiede riceve esattamente lo stesso contenuto. Non richiedono elaborazione lato server per essere generate. Implicazioni: Semplici da creare e ospitare, veloci da caricare, ma non interattive con dati specifici dell'utente o in tempo reale.\n\n**Pagine Web Dinamiche:** Il loro contenuto viene generato 'al volo' dal server in risposta a una richiesta specifica, spesso recuperando dati da un database o eseguendo logica di business. Il contenuto può variare per ogni utente o in base a parametri. Implicazioni: Più complesse da sviluppare (richiedono linguaggi server-side come Java, Python, PHP), ma offrono alta interattività, personalizzazione e capacità di gestire dati aggiornati. Richiedono un Application Server oltre a un Web Server."
    },
    {
        question: "Descrivi il concetto di 'sandbox' del browser e le sue implicazioni sulla gestione della memoria e dello stato tra il ricaricamento delle pagine. Come si può ovviare parzialmente al problema della perdita di stato tra un ricaricamento e l'altro?",
        correctAnswer: "Il browser esegue ogni pagina web all'interno di una 'sandbox', un ambiente isolato che impedisce alla pagina di accedere a risorse al di fuori del suo contesto e di interferire con altre pagine o con il sistema operativo. Ogni volta che una pagina viene ricaricata, la sua sandbox viene distrutta e ne viene creata una nuova. Questo implica che la **memoria dell'applicazione in esecuzione viene completamente persa** tra un ricaricamento e l'altro (es. variabili JavaScript, stato DOM modificato). Per ovviare parzialmente a questa perdita di stato, si possono utilizzare i meccanismi di **storage locali del browser**:\n- **`localStorage`:** Permette di memorizzare coppie chiave-valore persistenti (senza scadenza) specifiche per l'origine della pagina. I dati rimangono disponibili anche dopo la chiusura del browser.\n- **`sessionStorage`:** Simile a `localStorage`, ma i dati persistono solo per la durata della sessione della finestra/tab del browser (vengono cancellati alla chiusura della tab).\nQuesti meccanismi consentono di salvare e recuperare dati tra ricaricamenti, a patto che l'origine della pagina sia la stessa."
    },
    {
        question: "Descrivi in dettaglio l'elemento HTML `<form>`. Quali sono gli attributi `action` e `method` e il loro ruolo nell'invio dei dati? Fai un esempio di utilizzo degli elementi `<input type='text'>`, `<label>`, `<select>` con `<option>`, e dei tipi di input `submit` e `reset`.",
        correctAnswer: "L'elemento `<form>` in HTML è un contenitore per elementi interattivi che consentono all'utente di inserire dati, i quali possono essere inviati a un server per l'elaborazione. Gli attributi principali sono:\n- **`action`:** Specifica l'URL al quale i dati del form devono essere inviati quando il form viene sottomesso.\n- **`method`:** Specifica il metodo HTTP da utilizzare per inviare i dati del form (tipicamente `GET` o `POST`). `GET` aggiunge i dati all'URL come query string (visibile), `POST` li invia nel corpo della richiesta (più sicuro per dati sensibili).\n\n**Esempio:**\n```html\n<form action=\"/submit_dati\" method=\"POST\">\n    <label for=\"nomeUtente\">Nome Utente:</label>\n    <input type=\"text\" id=\"nomeUtente\" name=\"username\" placeholder=\"Inserisci il tuo nome\">\n    <br><br>\n    <label for=\"paese\">Scegli il Paese:</label>\n    <select id=\"paese\" name=\"user_country\">\n        <option value=\"\">--Seleziona--</option>\n        <option value=\"IT\">Italia</option>\n        <option value=\"US\">Stati Uniti</option>\n    </select>\n    <br><br>\n    <input type=\"submit\" value=\"Invia Dati\">\n    <input type=\"reset\" value=\"Cancella Form\">\n</form>\n```\n- `<input type='text'>`: Campo di testo per input singolo. L'attributo `name` è fondamentale per inviare il valore al server, `id` per associare la `label`, `placeholder` per il suggerimento.\n- `<label>`: Associa un testo descrittivo a un elemento del form tramite l'attributo `for` che corrisponde all'`id` dell'input, migliorando l'accessibilità.\n- `<select>` e `<option>`: Creano un menu a tendina. `<select>` ha un `name`, e ogni `<option>` ha un `value` che viene inviato se selezionato.\n- `<input type='submit'>`: Crea un bottone che, se cliccato, invia i dati del form all'URL specificato in `action` con il `method` definito.\n- `<input type='reset'>`: Crea un bottone che, se cliccato, ripristina i valori predefiniti di tutti i campi del form."
    },
    {
        question: "Spiega il concetto di `name` e `value` negli elementi di un form HTML quando vengono inviati al server.",
        correctAnswer: "Quando un form HTML viene sottomesso, i dati vengono raccolti dagli elementi del form e inviati al server sotto forma di coppie 'chiave-valore'.\n- **`name`:** È l'attributo che definisce la 'chiave' (o il nome del campo) per un dato elemento del form. È essenziale affinché il dato associato a quell'elemento venga inviato al server. Se un elemento non ha un attributo `name`, il suo valore non verrà incluso nei dati sottomessi.\n- **`value`:** È l'attributo che contiene il 'valore' associato alla 'chiave' (il `name`). Per `<input type='text'>`, `value` è il testo digitato dall'utente. Per `<input type='checkbox'>` o `<input type='radio'>`, `value` è il valore predefinito che viene inviato se l'elemento è selezionato. Per `<select>`, è il `value` dell'`<option>` selezionata. Per `submit` e `reset` (sebbene non fondamentali per i dati), `value` è il testo visualizzato sul bottone."
    },
    {
        question: "Spiega cos'è JSON e perché è diventato il formato preferito per lo scambio di dati nelle API web moderne. Qual è la sua relazione con JavaScript?",
        correctAnswer: "**JSON (JavaScript Object Notation)** è un formato leggero per lo scambio di dati. È basato su un sottoinsieme della sintassi del linguaggio JavaScript, ma è indipendente dal linguaggio di programmazione, il che significa che può essere letto e scritto da qualsiasi linguaggio. La sua popolarità deriva da:\n1.  **Leggibilità Umana:** È facile da leggere e scrivere per gli esseri umani.\n2.  **Facilità di Parsing:** È facile da analizzare (parse) e generare per le macchine.\n3.  **Leggerezza:** Ha una sintassi concisa che lo rende efficiente per la trasmissione dati rispetto ad altri formati (es. XML).\n\nLa sua relazione con JavaScript è profonda: JSON è nato come una notazione per rappresentare oggetti JavaScript. Questo lo rende estremamente efficiente per le applicazioni web che usano JavaScript lato client, in quanto i dati JSON possono essere convertiti direttamente in oggetti JavaScript (usando `JSON.parse()`) e viceversa (usando `JSON.stringify()`) senza bisogno di librerie complesse o conversioni elaborate. Questo lo rende ideale per la comunicazione tra il browser e le API RESTful lato server."
    },
    {
        question: "Spiega il ruolo della Fetch API in JavaScript. Come si utilizza per effettuare richieste HTTP (GET, POST) e gestire le risposte (JSON) in modo asincrono? Fai un esempio.",
        correctAnswer: "La **Fetch API** è un'interfaccia JavaScript moderna e basata su Promises per effettuare richieste di rete (HTTP) in modo asincrono. Sostituisce in gran parte l'obsoleto `XMLHttpRequest` fornendo un'interfaccia più potente e flessibile per lavorare con risorse (API web).\n\n**Utilizzo (Esempio):**\n```javascript\n// Richiesta GET\nfetch('[https://api.example.com/data](https://api.example.com/data)')\n  .then(response => {\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    return response.json(); // Parsa il body della risposta come JSON\n  })\n  .then(data => {\n    console.log('Dati ricevuti:', data);\n  })\n  .catch(error => {\n    console.error('Errore durante la fetch:', error);\n  });\n\n// Richiesta POST con dati JSON\nconst postData = { nome: 'Prodotto X', prezzo: 29.99 };\nfetch('[https://api.example.com/products](https://api.example.com/products)', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json' // Indica che il body è JSON\n  },\n  body: JSON.stringify(postData) // Converte l'oggetto JS in stringa JSON\n})\n  .then(response => response.json()) // Parsa la risposta JSON\n  .then(data => {\n    console.log('Prodotto creato:', data);\n  })\n  .catch(error => {\n    console.error('Errore creazione prodotto:', error);\n  });\n```\n`fetch()` ritorna una Promise. Il primo `.then()` riceve l'oggetto `Response`, che deve essere controllato per errori (`response.ok`) e poi processato (es. `response.json()`, `response.text()`). Il secondo `.then()` riceve i dati processati. `.catch()` gestisce eventuali errori di rete o nel parsing."
    },
    {
        question: "Spiega il concetto di 'inferenza dei tipi' in TypeScript. Quando TypeScript è in grado di dedurre un tipo senza che venga esplicitamente dichiarato, e quali sono i vantaggi di questa funzionalità?",
        correctAnswer: "L'**inferenza dei tipi** in TypeScript è la capacità del compilatore TypeScript di 'indovinare' il tipo di una variabile, di un parametro di funzione o del valore di ritorno di una funzione senza che lo sviluppatore lo dichiari esplicitamente. Questo avviene analizzando il valore assegnato o il contesto di utilizzo.\n\n**Quando avviene:**\n- **Dichiarazione con inizializzazione:** `let x = 10;` (TypeScript inferisce `x` come `number`).\n- **Valore di ritorno di funzione:** `function add(a: number, b: number) { return a + b; }` (TypeScript inferisce il ritorno come `number`).\n- **Assegnazione di proprietà:** `const user = { name: 'Alice' };` (TypeScript inferisce `user.name` come `string`).\n\n**Vantaggi:**\n- **Meno codice boilerplate:** Non è necessario scrivere esplicitamente i tipi ovunque, rendendo il codice più pulito e conciso.\n- **Produttività:** Migliora l'esperienza di sviluppo mantenendo i benefici del controllo dei tipi statico (autocompletamento, refactoring, rilevamento errori) senza la necessità di dichiarare ogni singolo tipo.\n- **Flessibilità:** Permette di bilanciare tra la rigidità della tipizzazione esplicita e la velocità di sviluppo tipica di JavaScript, rendendo TypeScript molto adottabile."
    },
    {
        question: "Spiega la differenza tra un documento XML 'well-formed' e un documento XML 'valid'. Qual è il ruolo di uno schema XML (es. XML Schema o DTD) nella validazione di un documento XML?",
        correctAnswer: "- **Well-formed (Ben Formato):** Un documento XML è 'well-formed' se rispetta le regole sintattiche fondamentali di XML. Questo include:\n    * Avere un solo elemento radice.\n    * Tutti i tag devono essere correttamente aperti e chiusi e nidificati (`<tag><inner></inner></tag>`).\n    * I valori degli attributi devono essere racchiusi tra virgolette.\n    * I nomi degli elementi e degli attributi devono seguire le regole di naming XML.\n    * Essere correttamente codificato.\n- **Valid (Valido):** Un documento XML è 'valid' se, oltre ad essere 'well-formed', rispetta anche un insieme di regole semantiche e strutturali definite da uno **schema XML**. Questo significa che il contenuto, la struttura e il tipo di dati degli elementi e degli attributi sono conformi a quanto stabilito nello schema.\n\n**Ruolo dello Schema XML (XML Schema o DTD):**\nUno schema XML (come XML Schema Definition - XSD, o Document Type Definition - DTD) è un documento che definisce la struttura legale, il contenuto e i tipi di dati dei documenti XML. Funziona come una 'grammatica' o un 'contratto' per i documenti XML. Il suo ruolo è:\n- **Validazione:** Permette di validare un documento XML, verificando che sia conforme alle regole definite nello schema. Questo assicura che il documento abbia la struttura e i dati attesi.\n- **Documentazione:** Serve come documentazione della struttura dei dati XML, facilitando lo scambio di dati tra diverse applicazioni.\n- **Supporto IDE:** Gli IDE possono utilizzare lo schema per fornire autocompletamento e validazione in tempo reale durante la scrittura di documenti XML."
    },
    {
        question: "Descrivi le principali funzioni di un Web Server nell'elaborazione di contenuto dinamico (es. Request Handling, Request Processing, Response Output, Error Handling).",
        correctAnswer: "Oltre a servire file statici, un Web Server (o un Application Server che integra le funzionalità di Web Server) svolge diverse funzioni chiave nell'elaborazione di contenuto dinamico:\n1.  **Request Handling:** Il server riceve le richieste HTTP in entrata. Si occupa di parsare gli header, il metodo HTTP e l'URL, e di identificare la risorsa richiesta e il client.\n2.  **Request Processing:** Per le risorse dinamiche, il server non serve un file preesistente. Invece, inoltra la richiesta a un componente di elaborazione dinamica (es. una Servlet in Java, un'applicazione Express.js in Node.js, uno script PHP). Questo componente esegue la logica di business, interagisce con database o altri servizi e genera il contenuto della risposta.\n3.  **Response Output:** Una volta che il contenuto dinamico è stato generato (spesso HTML, JSON, XML), il server raccoglie questa output, aggiunge gli header HTTP appropriati (es. `Content-Type`, `Content-Length`) e invia la risposta completa al client.\n4.  **Error Handling:** Il server è responsabile di gestire gli errori che si verificano durante il processo di richiesta/risposta (es. risorsa non trovata - 404, errore interno del server - 500, accesso non autorizzato - 401/403). Genera e invia le risposte di errore appropriate al client."
    },
    {
        question: "Spiega l'utilità del concetto di 'middleware' in un framework server-side come Express.js o Spring. Fornisci un esempio di un task comune che potrebbe essere gestito da un middleware.",
        correctAnswer: "Il **middleware** in un framework server-side è un software che agisce come un intermediario tra la ricezione di una richiesta HTTP e l'elaborazione finale della logica di business (il 'request handler'). I middleware sono funzioni che hanno accesso all'oggetto richiesta (`req`), all'oggetto risposta (`res`) e alla funzione `next()` del ciclo request-response dell'applicazione. Possono eseguire codice, apportare modifiche agli oggetti request e response, terminare il ciclo request-response o passare il controllo al middleware successivo nella pila.\n\n**Utilità:** I middleware sono fondamentali per organizzare il codice in modo modulare e riutilizzabile, gestendo compiti trasversali che si applicano a molte o tutte le richieste, come:\n- Logging delle richieste\n- Autenticazione e autorizzazione\n- Parsing del body della richiesta (JSON, form data)\n- Gestione delle sessioni\n- Compressione delle risposte\n- Gestione degli errori\n\n**Esempio di Task gestito da un middleware (Autenticazione):**\nUn middleware di autenticazione può essere utilizzato per verificare se un utente è loggato prima di permettergli l'accesso a determinate risorse protette. Ogni richiesta HTTP che arriva a una route protetta passerebbe prima attraverso questo middleware. Se l'utente non è autenticato, il middleware potrebbe bloccare la richiesta e inviare una risposta 401 Unauthorized, altrimenti, se autenticato, passerebbe il controllo al prossimo middleware o al request handler.\n\n**In Express.js:**\n```javascript\napp.use((req, res, next) => {\n  console.log('Richiesta ricevuta:', req.method, req.url); // Middleware di logging\n  next(); // Passa il controllo al prossimo middleware/handler\n});\n\napp.get('/protected', (req, res, next) => {\n  // Esempio di middleware di autenticazione inline\n  if (!req.session || !req.session.userId) {\n    return res.status(401).send('Non autorizzato');\n  }\n  next();\n}, (req, res) => {\n  res.send('Contenuto protetto');\n});\n```\n\n**In Spring (Interceptor/Filter):**\nSpring utilizza concetti simili come `HandlerInterceptor` o `Filter` che intercettano le richieste prima che raggiungano i Controller, gestendo compiti analoghi."
    },
    {
        question: "Qual è il ruolo di un `EntityManager` e di un `DataSource` nel contesto di un'applicazione Spring Data JPA? Come vengono tipicamente configurati e qual è la loro relazione con la connessione al database?",
        correctAnswer: "- **`DataSource`:** È l'interfaccia standard Java per ottenere connessioni a un database. Rappresenta una factory per le connessioni al DB. In un'applicazione Spring, il `DataSource` viene tipicamente configurato tramite proprietà nel file `application.properties` (es. `spring.datasource.url`, `spring.datasource.username`, `spring.datasource.password`). Spring Boot autoconfigura un `DataSource` se trova i driver del database nel classpath. Il suo ruolo è fornire le connessioni fisiche al database in modo efficiente, spesso tramite un connection pool.\n\n- **`EntityManager`:** È l'interfaccia principale dell'API JPA per interagire con il contesto di persistenza. Un `EntityManager` è responsabile della gestione del ciclo di vita delle entità (creazione, lettura, aggiornamento, eliminazione), della persistenza degli oggetti nel database e della gestione delle transazioni. È il punto di contatto tra l'applicazione e l'ORM (es. Hibernate, l'implementazione di JPA). Ogni `EntityManager` è associato a una sessione o transazione del database.\n\n**Relazione e Configurazione:**\nSpring Data JPA (e Hibernate sottostante) utilizza il `DataSource` per ottenere le connessioni al database. Queste connessioni vengono poi utilizzate dall'`EntityManager` per eseguire le operazioni di persistenza. In un'applicazione Spring Boot, l'`EntityManagerFactory` (che crea gli `EntityManager`) e il `DataSource` vengono automaticamente configurati da Spring Boot se si includono le dipendenze `spring-boot-starter-data-jpa` e un driver di database. L'`EntityManager` viene poi iniettato nei Service o Repository per l'uso."
    }
]