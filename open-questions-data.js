let openQuestionsData = [
    {
        question: "Qual è la differenza tra un Web Server e un HTTP Server? Perché in certi casi coincidono?",
        correctAnswer: "Un Web Server è un software che memorizza e distribuisce contenuti web statici (HTML, CSS, JS, immagini) ai client tramite HTTP. Un HTTP Server, più genericamente, implementa e gestisce il protocollo HTTP per scambiare dati. Spesso coincidono perché HTTP è il protocollo fondamentale e quasi esclusivo per la distribuzione di risorse sul World Wide Web, rendendo un Web Server un caso specifico e primario di HTTP Server che si occupa di contenuti web.",
        keywords: ["web server", "http server", "distribuisce", "protocollo http", "coincidono", "contenuti statici", "world wide web"]
    },
    {
        question: "Spiega il ruolo dell'HTTP in un'architettura client-server.",
        correctAnswer: "HTTP (HyperText Transfer Protocol) è il protocollo di comunicazione stateless e testuale che funge da fondamento per lo scambio di informazioni sul World Wide Web. In un'architettura client-server, permette al client (es. browser) di inviare richieste (es. GET, POST) al server per ottenere o inviare risorse, e al server di rispondere con i dati richiesti o esiti delle operazioni. È la base che abilita la navigazione, l'interazione con API e il trasferimento di documenti web.",
        keywords: ["http", "protocollo", "comunicazione", "client-server", "richieste", "risposte", "stateless", "testuale", "world wide web", "api"]
    },
    {
        question: "Descrivi le componenti principali dell'architettura a tre livelli (3-tier) in un'applicazione web.",
        correctAnswer: "L'architettura a tre livelli (3-tier) divide un'applicazione in tre strati logici distinti per migliorare la scalabilità, la modularità e la manutenibilità: 1. **Livello di Presentazione (Client/UI)**: L'interfaccia utente che interagisce direttamente con l'utente (es. browser, app mobile). 2. **Livello Logico (Business Logic/Application Tier)**: Contiene la logica di business, elabora le richieste dal livello di presentazione e coordina l'accesso ai dati. 3. **Livello Dati (Database Tier)**: Gestisce la persistenza dei dati, l'archiviazione e il recupero delle informazioni (es. database SQL/NoSQL).",
        keywords: ["presentazione", "logico", "dati", "3-tier", "architettura", "client", "business logic", "database", "scalabilità", "modularità", "manutenibilità"]
    },
    {
        question: "Cosa significa RESTful e quali sono le caratteristiche di un'architettura REST?",
        correctAnswer: "RESTful si riferisce a un'architettura che segue i principi di REST (Representational State Transfer), uno stile architettonico per sistemi distribuiti. Le caratteristiche principali sono: **Client-Server**: separazione delle responsabilità; **Stateless**: ogni richiesta dal client al server deve contenere tutte le informazioni necessarie; **Cacheable**: le risposte possono essere dichiarate come memorizzabili in cache; **Uniform Interface**: un set uniforme di vincoli per l'interfaccia (es. uso di URL per identificare risorse, metodi HTTP standard); **Layered System**: il sistema può essere organizzato a strati; **Code-On-Demand (opzionale)**: il server può estendere la funzionalità del client inviando codice eseguibile.",
        keywords: ["restful", "rest", "client-server", "stateless", "cacheable", "uniform interface", "layered system", "architettura", "sistema distribuito", "http", "risorse"]
    },
    {
        question: "Spiega cosa sono le API REST e come vengono consumate da un client.",
        correctAnswer: "Le API REST (Application Programming Interfaces) sono interfacce che permettono a sistemi software diversi di comunicare tra loro seguendo i principi architetturali REST e utilizzando il protocollo HTTP. Vengono consumate da un client inviando richieste HTTP (come GET per recuperare dati, POST per crearne di nuovi, PUT per aggiornare, DELETE per rimuovere) a specifici URL chiamati 'endpoint'. Il server elabora la richiesta e invia una risposta, tipicamente formattata in JSON (JavaScript Object Notation) o XML (eXtensible Markup Language), che il client poi interpreta.",
        keywords: ["api rest", "http", "json", "endpoint", "get", "post", "put", "delete", "xml", "comunicazione", "client"]
    },
    {
        question: "Quali sono le due API principali usate da JavaScript lato client? Spiegane il ruolo.",
        correctAnswer: "Le due categorie principali di API usate da JavaScript lato client sono: 1. **Web API (o Browser API)**: Fornite dall'ambiente del browser, permettono a JavaScript di interagire con il browser e il DOM (es. DOM API per manipolare la struttura HTML, Fetch API per richieste di rete, Geolocation API per la posizione). 2. **Core JavaScript API (o Native API)**: Integrate nel linguaggio stesso, offrono funzionalità di base per la manipolazione di dati (es. oggetti `Array`, `Object`, `Math`, `Date`, `JSON`). Il loro ruolo è estendere le capacità di JavaScript oltre la pura logica computazionale, permettendogli di creare interfacce dinamiche e comunicare con il mondo esterno.",
        keywords: ["web api", "core javascript api", "dom", "fetch", "browser", "oggetti nativi", "lato client", "interazione", "javascript"]
    },
    {
        question: "Spiega il concetto di callback in JavaScript con un esempio.",
        correctAnswer: "Una callback è una funzione passata come argomento a un'altra funzione, con l'intento che venga eseguita in un momento successivo, spesso dopo il completamento di un'operazione asincrona. Questo modello è fondamentale per gestire eventi o operazioni che richiedono tempo, senza bloccare l'esecuzione del programma. Esempio: `function salutaDopo(nome, callback) { setTimeout(() => { console.log('Ciao, ' + nome); callback(); }, 2000); } salutaDopo('Marco', () => { console.log('Operazione completata!'); });` Qui la funzione anonima è la callback che viene eseguita dopo il `setTimeout`.",
        keywords: ["callback", "funzione", "argomento", "asincrona", "esecuzione", "esempio", "settimeout", "non bloccante", "event-driven"]
    },
    {
        question: "Cosa si intende per event loop in JavaScript e come gestisce le callback asincrone?",
        correctAnswer: "L'Event Loop è un meccanismo fondamentale che permette a JavaScript, pur essendo single-threaded (eseguendo un solo comando alla volta), di gestire operazioni asincrone e non bloccanti. Funziona monitorando lo 'Stack di Esecuzione' (dove il codice sincrono viene eseguito) e la 'Coda di Callback' (o 'Task Queue'), dove le callback di operazioni asincrone (es. `setTimeout`, `Fetch`, eventi DOM) vengono messe in attesa. Quando lo Stack di Esecuzione è vuoto, l'Event Loop sposta le callback dalla Coda allo Stack, permettendone l'esecuzione e impedendo che operazioni lunghe blocchino il thread principale dell'UI.",
        keywords: ["event loop", "javascript", "single-threaded", "asincrone", "coda callback", "stack esecuzione", "non bloccante", "concorrenza", "browser"]
    },
    {
        question: "Cos'è la Fetch API e come si usa per effettuare chiamate HTTP?",
        correctAnswer: "La Fetch API è una moderna interfaccia JavaScript nativa dei browser per effettuare richieste di rete (HTTP) in modo asincrono. Offre un'alternativa più flessibile e potente a `XMLHttpRequest` e si basa sulle Promises, semplificando la gestione delle risposte. Si usa chiamando `fetch(url, options?)`, dove `url` è l'endpoint e `options` (facoltativo) include dettagli come il metodo HTTP (GET, POST), gli header, o il body. La funzione `fetch` restituisce una Promise che si risolve con l'oggetto `Response` una volta ricevuti gli header, e un'altra Promise per accedere al body della risposta (es. `response.json()`).",
        keywords: ["fetch api", "http", "richieste", "promise", "url", "javascript", "asincrono", "browser", "xmlhttprequest", "json"]
    },
    {
        question: "Spiega la differenza tra setTimeout, setInterval e requestAnimationFrame.",
        correctAnswer: "Queste sono funzioni per schedulare l'esecuzione di codice asincrono in JavaScript: **`setTimeout(funzione, ritardo)`** esegue una funzione una singola volta dopo un specificato `ritardo` in millisecondi. **`setInterval(funzione, intervallo)`** esegue una funzione ripetutamente ogni `intervallo` di millisecondi indefinitamente, finché non viene fermata con `clearInterval`. **`requestAnimationFrame(funzione)`** esegue una funzione prima del prossimo repaint (ridisegno) del browser, ottimizzando le animazioni per fluidità ed efficienza energetica, sincronizzandosi con il refresh rate del monitor. È ideale per animazioni visive.",
        keywords: ["settimeout", "setinterval", "requestanimationframe", "ritardo", "ripetizione", "animazione", "browser", "asincrono", "performance", "repaint"]
    },
    {
        question: "Cos'è il DOM e come JavaScript può interagirci?",
        correctAnswer: "Il DOM (Document Object Model) è una rappresentazione programmatica, gerarchica e ad albero di una pagina web (documento HTML/XML). Ogni nodo dell'albero rappresenta un elemento, attributo o testo del documento. JavaScript interagisce con il DOM tramite le Web API (DOM API) fornite dal browser. Questo permette a JavaScript di accedere a specifici elementi (es. `document.getElementById()`), modificarne il contenuto (es. `innerHTML`), gli attributi (es. `setAttribute()`), lo stile (es. `style.color`), di creare o rimuovere elementi, e di reagire a eventi utente (es. `addEventListener('click', ...)`), rendendo le pagine dinamiche e interattive.",
        keywords: ["dom", "document object model", "albero", "html", "css", "javascript", "manipolare", "eventi", "nodi", "web api", "browser"]
    },
    {
        question: "Spiega il significato del termine 'single-threaded' riferito a JavaScript.",
        correctAnswer: "'Single-threaded' significa che JavaScript esegue un solo comando o processo alla volta in un unico thread di esecuzione. Non può eseguire codice in parallelo nello stesso thread, il che significa che un'operazione che richiede molto tempo bloccherebbe l'intera interfaccia utente. Le operazioni asincrone (come I/O, timer, fetch) vengono gestite delegandole al browser o al Node.js runtime (Web API, Node.js API), che le eseguono in background. Una volta completate, le loro callback vengono messe in coda e processate dal thread principale di JavaScript tramite l'Event Loop quando è libero, garantendo un'interfaccia utente reattiva nonostante la natura single-threaded.",
        keywords: ["single-threaded", "javascript", "un solo comando", "parallelo", "event loop", "asincrono", "thread", "non bloccante", "web api", "node.js"]
    },
    {
        question: "Descrivi cosa sono le closure e il loro utilizzo.",
        correctAnswer: "Una closure in JavaScript è la combinazione di una funzione con l'ambiente lessicale (lo scope) in cui è stata dichiarata. Permette a una funzione interna (o 'nested function') di accedere e 'ricordare' le variabili della funzione esterna anche dopo che la funzione esterna ha terminato l'esecuzione e il suo scope è teoricamente uscito. Utilizzi comuni includono: **Data Privacy/Incapsulamento**: per creare variabili 'private' accessibili solo tramite metodi pubblici; **Funzioni Factory**: per generare funzioni personalizzate; **Gestione dello Stato**: in pattern come i moduli o per mantenere uno stato persistente in un contesto asincrono.",
        keywords: ["closure", "funzione", "scope", "ambiente lessicale", "variabili", "data privacy", "incapsulamento", "funzioni factory", "javascript"]
    },
    {
        question: "Qual è il ruolo degli eventi in JavaScript e come vengono gestiti (event bubbling e capturing)?",
        correctAnswer: "Gli eventi in JavaScript rappresentano azioni o occorrenze sul DOM (es. click del mouse, pressione di un tasto, caricamento di una pagina, invio di un form) che il browser rileva. Gli sviluppatori gestiscono questi eventi associando 'event listener' (funzioni callback) agli elementi del DOM. La propagazione degli eventi nell'albero DOM avviene in due fasi: **Capturing (dall'esterno all'interno)**: L'evento si propaga dalla radice del DOM (document) verso l'elemento target. **Bubbling (dall'interno all'esterno)**: Dopo aver raggiunto l'elemento target, l'evento 'risale' verso la radice, attivando listener su elementi genitori. Il bubbling è la fase predefinita. Si possono prevenire ulteriori propagazioni con `event.stopPropagation()` e l'azione predefinita del browser con `event.preventDefault()`.",
        keywords: ["eventi", "javascript", "dom", "event listener", "bubbling", "capturing", "propagazione", "callback", "event.stoppropagation", "event.preventdefault", "interazione utente"]
    },
    {
        question: "Spiega cos'è il Cross Site Scripting (XSS) e come può essere mitigato.",
        correctAnswer: "Il Cross-Site Scripting (XSS) è una vulnerabilità di sicurezza web che permette a un attaccante di iniettare script malevoli (solitamente JavaScript) lato client in pagine web visualizzate da altri utenti. Questi script possono rubare cookie, session token, manipolare il DOM o reindirizzare l'utente. Può essere **Reflected XSS** (script riflesso dal server in una singola richiesta), **Stored XSS** (script persistente nel database del server) o **DOM-based XSS** (vulnerabilità lato client). La mitigazione include: **Input Validation**: validare e sanificare tutti gli input utente; **Output Encoding/Escaping**: codificare i dati prima di renderli nel HTML per neutralizzare script; **Content Security Policy (CSP)**: una direttiva HTTP che controlla le risorse che il browser è autorizzato a caricare; uso di librerie di sanificazione.",
        keywords: ["xss", "cross site scripting", "vulnerabilità", "script malevoli", "mitigazione", "input validation", "output encoding", "csp", "sicurezza web", "attacco", "cookie", "dom"]
    },
    {
        question: "Che differenza c'è tra autenticazione e autorizzazione in un'applicazione web?",
        correctAnswer: "Sono due concetti distinti ma correlati nel controllo degli accessi: **Autenticazione** è il processo di verificare l'identità di un utente o di un sistema. Risponde alla domanda 'Sei chi dici di essere?' e tipicamente avviene tramite credenziali (username/password), token, biometria, ecc.. **Autorizzazione** è il processo di determinare a quali risorse, funzioni o azioni un utente (già autenticato) ha permesso di accedere o eseguire. Risponde alla domanda 'Cosa ti è permesso fare?' e si basa su ruoli, permessi o policy assegnati all'utente. L'autenticazione precede sempre l'autorizzazione.",
        keywords: ["autenticazione", "autorizzazione", "identità", "accesso", "chi sei", "cosa puoi fare", "sicurezza", "credenziali", "ruoli", "permessi"]
    },
    {
        question: "Cos'è il Same-Origin Policy e a cosa serve?",
        correctAnswer: "Il Same-Origin Policy (SOP) è una cruciale misura di sicurezza implementata dai browser web. Impedisce a script eseguiti su una pagina web da un'origine di interagire con risorse (es. dati, DOM) caricate da un'altra origine, a meno che non ci siano espliciti permessi. Un'origine è definita dalla combinazione di protocollo (es. HTTP/HTTPS), host (dominio) e porta. Serve a prevenire attacchi malevoli come il furto di dati tra siti (es. leggendo cookie o dati sensibili da un'altra tab), clickjacking o iniezioni CSRF. Meccanismi come CORS (Cross-Origin Resource Sharing) consentono, in modo controllato, la condivisione di risorse tra origini diverse quando è intenzionale.",
        keywords: ["same-origin policy", "sop", "sicurezza", "browser", "origini diverse", "attacchi", "cors", "dominio", "protocollo", "porta"]
    },
    {
        question: "Spiega cos'è TypeScript e quali vantaggi offre rispetto a JavaScript.",
        correctAnswer: "TypeScript è un superset open-source di JavaScript sviluppato da Microsoft che aggiunge la tipizzazione statica opzionale al linguaggio. Il codice TypeScript viene 'transpilato' in JavaScript puro per poter essere eseguito in qualsiasi ambiente JavaScript. Vantaggi principali: 1. **Rilevamento errori in fase di compilazione**: Molti bug legati ai tipi vengono scoperti prima dell'esecuzione. 2. **Miglioramento dell'autocompletamento e del refactoring**: Gli IDE possono fornire suggerimenti più accurati e refactoring più sicuri grazie alle informazioni sui tipi. 3. **Maggiore manutenibilità**: Rende il codice più leggibile, comprensibile e robusto, specialmente in progetti di grandi dimensioni o con team numerosi. 4. **Supporto per funzionalità ES Next**: Include le ultime funzionalità JavaScript prima che siano ampiamente supportate dai browser. 5. **Interfacce e Generici**: Permette di definire contratti di dati e di scrivere codice riutilizzabile e tipo-sicuro.",
        keywords: ["typescript", "javascript", "superset", "tipizzazione statica", "vantaggi", "compilazione", "manutenibilità", "errori", "refactoring", "interfacce", "generici", "transpilazione"]
    },
    {
        question: "Quali sono le principali caratteristiche di TypeScript che lo differenziano da JavaScript?",
        correctAnswer: "Le principali caratteristiche che differenziano TypeScript da JavaScript sono l'aggiunta di: **Tipi Statici**: Permette di dichiarare esplicitamente i tipi di variabili, parametri di funzione e valori di ritorno (es. `let x: number = 10;`), supportando tipi primitivi, unioni, intersezioni, tuple, `any`, `unknown`. **Interfacce**: Per definire la 'forma' che gli oggetti devono avere. **Classi con Modificatori di Accesso**: Supporto per `public`, `private`, `protected` sui membri delle classi. **Decoratori**: Funzioni speciali per annotare classi, metodi, proprietà o parametri. **Enumerazioni (Enums)**: Per definire un insieme di costanti nominali. **Moduli Avanzati**: Migliore gestione dei moduli per l'organizzazione del codice. Tutte queste caratteristiche non sono presenti nativamente in JavaScript e vengono rimosse durante la transpilazione a JavaScript standard per l'esecuzione nel browser o Node.js.",
        keywords: ["typescript", "javascript", "tipi statici", "interfacce", "classi", "decoratori", "transpila", "enumerazioni", "modificatori accesso", "superset", "tipo sicurezza"]
    },
    {
        question: "Perché usare i tipi statici in un linguaggio dinamico come JavaScript?",
        correctAnswer: "L'uso dei tipi statici (tramite TypeScript) in un linguaggio dinamico come JavaScript introduce notevoli vantaggi, nonostante JavaScript sia intrinsecamente non tipizzato a runtime. I tipi statici migliorano la **robustezza e l'affidabilità** del codice, catturando una vasta categoria di errori comuni (es. typo, errori di tipo, refactoring non corretto) già in fase di sviluppo/compilazione, prima che il codice venga eseguito. Aumentano la **chiarezza e la prevedibilità** del codice, agendo come una forma di documentazione self-documentante, facilitando la comprensione del flusso di dati e l'intento del programmatore. Facilitano la **collaborazione in team** e la **manutenzione** di basi di codice estese e complesse, riducendo i tempi di debugging e migliorando l'esperienza degli sviluppatori grazie a strumenti IDE più potenti (autocompletamento, refactoring sicuro).",
        keywords: ["tipi statici", "javascript", "typescript", "robustezza", "errori", "chiarezza", "manutenzione", "sviluppo", "debugging", "ide", "collaborazione"]
    },
    {
        question: "Spiega cos'è una Servlet e descrivi il suo ciclo di vita.",
        correctAnswer: "Una Servlet è una classe Java che estende le capacità di un server (solitamente un web server o application server) fornendo funzionalità dinamiche per gestire richieste client e generare risposte. Le Servlet sono un componente chiave di Jakarta EE. Il loro ciclo di vita è gestito dal container web (es. Apache Tomcat): 1. **`init()`**: Chiamato una sola volta all'inizializzazione della Servlet (es. al primo accesso o all'avvio del server) per eseguire operazioni di setup e caricare risorse. 2. **`service(ServletRequest req, ServletResponse res)`**: Chiamato per ogni richiesta client. Delega l'elaborazione a metodi specifici come `doGet()`, `doPost()`, `doPut()`, `doDelete()` in base al metodo HTTP della richiesta. 3. **`destroy()`**: Chiamato una sola volta dal container quando la Servlet sta per essere rimossa, permettendo la pulizia delle risorse (es. chiusura connessioni al database).",
        keywords: ["servlet", "java", "server", "richieste", "risposte", "ciclo di vita", "init", "service", "destroy", "jakarta ee", "web container", "doGet", "doPost"]
    },
    {
        question: "Cos'è Jakarta EE e quale ruolo ha nello sviluppo web?",
        correctAnswer: "Jakarta EE (precedentemente Java EE) è un insieme di specifiche standard per la piattaforma Java che fornisce un framework robusto e scalabile per lo sviluppo di applicazioni enterprise, incluse quelle web distribuite e microservizi. Il suo ruolo nello sviluppo web è fornire un ambiente standardizzato e una vasta gamma di API (come Servlets, JSP, EJB, JPA, JAX-RS per RESTful web services) e servizi (es. transazioni, sicurezza, messaging) che semplificano la creazione di applicazioni complesse e mission-critical lato server. Garantisce portabilità del codice tra diversi application server conformi alle specifiche.",
        keywords: ["jakarta ee", "java ee", "specifiche", "enterprise", "sviluppo web", "api", "server", "framework", "distribuite", "microservizi", "standardizzazione", "servlet", "jpa", "jax-rs"]
    },
    {
        question: "Confronta Jakarta EE con Spring: quali sono le principali differenze e casi d'uso?",
        correctAnswer: "Jakarta EE è un insieme di **specifiche standard** per la piattaforma Java enterprise, implementate da diversi application server (es. WildFly, GlassFish). È 'opinionated' e offre una soluzione 'all-in-one', spesso risultando in server d'applicazione più pesanti, ma garantendo portabilità e interoperabilità tra vendor. È ideale per applicazioni enterprise tradizionali, monolitiche o che richiedono conformità rigorosa agli standard. Spring è un **framework open-source leggero e modulare** che offre soluzioni per quasi ogni aspetto dello sviluppo Java, dalla configurazione all'accesso ai dati, passando per la sicurezza. Promuove principi come l'Inversion of Control (IoC) e la Dependency Injection (DI). È estremamente flessibile, permette la scelta dei componenti e si adatta bene a microservizi, applicazioni reattive e batch processing, offrendo una maggiore libertà e velocità di sviluppo, specialmente con Spring Boot.",
        keywords: ["jakarta ee", "spring", "differenze", "specifiche", "framework", "java enterprise", "ioc", "di", "application server", "microservizi", "monolitico", "flessibilità", "standard"]
    },
    {
        question: "Cosa aggiunge Spring Boot rispetto a Spring? Perché è utile?",
        correctAnswer: "Spring Boot è un progetto del framework Spring che mira a semplificare drasticamente la configurazione e lo sviluppo di applicazioni basate su Spring. Non è un'alternativa a Spring, ma un'estensione. Aggiunge: **Configurazione Automatica**: Configura automaticamente l'applicazione Spring basandosi sulle dipendenze presenti nel classpath, riducendo il 'boilerplate code'. **Server Embedded**: Permette di pacchettizzare l'applicazione come un JAR eseguibile con un server web integrato (es. Tomcat, Jetty, Undertow), eliminando la necessità di deployare su un server d'applicazione esterno. **Dipendenze 'Starter'**: Fornisce set di dipendenze pre-configurate per scenari comuni (es. `spring-boot-starter-web`, `spring-boot-starter-data-jpa`). È utile perché velocizza enormemente lo sviluppo e il deployment, facilitando la creazione di applicazioni standalone e microservizi con una configurazione minima.",
        keywords: ["spring boot", "spring", "semplifica", "configurazione automatica", "server embedded", "starter", "sviluppo rapido", "boilerplate", "jar", "microservizi", "deployment"]
    },
    {
        question: "Spiega come si sviluppa un'applicazione RESTful con Spring Boot.",
        correctAnswer: "Sviluppare un'applicazione RESTful con Spring Boot è altamente efficiente. Si inizia usando la dipendenza `spring-boot-starter-web`. Si creano classi Java annotate con `@RestController` per definire i controller REST, che combinano `@Controller` e `@ResponseBody`, assicurando che i metodi restituiscano direttamente dati (es. JSON/XML) anziché nomi di view. Si usano annotazioni come `@RequestMapping`, `@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping` per mappare gli URL agli specifici metodi handler che gestiscono le richieste HTTP. L'iniezione delle dipendenze viene gestita con `@Autowired`. Per la persistenza dei dati, si integrano Spring Data JPA e Hibernate con `@Entity` e `@Repository`, che semplificano le operazioni CRUD sul database. Spring Boot configura automaticamente un server embedded e converte le risposte degli oggetti in JSON/XML per il client.",
        keywords: ["restful", "spring boot", "@restcontroller", "@requestmapping", "@autowired", "json", "endpoint", "jpa", "spring data", "hibernate", "getmapping", "postmapping", "crud", "controller"]
    },
    {
        question: "Cos'è il Dependency Injection e come viene usato in Spring?",
        correctAnswer: "Dependency Injection (DI) è un pattern di progettazione in cui le dipendenze di un oggetto (ovvero, gli altri oggetti o servizi di cui ha bisogno per funzionare) vengono 'iniettate' o fornite esternamente, piuttosto che essere create dall'oggetto stesso. Questo promuove l'inversione di controllo (IoC) e rende il codice più modulare, testabile e meno accoppiato. In Spring, l'IoC container (implementato dall'ApplicationContext) gestisce la DI. Il container crea gli 'oggetti' (chiamati 'bean'), risolve le loro dipendenze e le inietta automaticamente negli oggetti che le richiedono. Ciò avviene tipicamente tramite: **Costruttori** (preferito per dipendenze obbligatorie), **Metodi Setter** o **Iniezione su campi** (tramite l'annotazione `@Autowired`).",
        keywords: ["dependency injection", "di", "pattern", "dipendenze", "spring", "ioc container", "bean", "inversion of control", "@autowired", "testabilità", "accoppiamento"]
    },
    {
        question: "Descrivi cosa sono e come funzionano le annotazioni @Controller, @RestController, @Autowired e @RequestMapping in Spring.",
        correctAnswer: "Le annotazioni in Spring sono metadati che forniscono istruzioni al framework sul comportamento del codice: **`@Controller`**: Indica che una classe è un componente Spring che gestisce le richieste HTTP e può restituire nomi di view (pagine HTML). Spesso usata nelle applicazioni MVC tradizionali. **`@RestController`**: È una specializzazione di `@Controller` che include implicitamente `@ResponseBody`. Viene utilizzata per costruire servizi web RESTful, indicando che i valori di ritorno dei metodi devono essere serializzati direttamente nel corpo della risposta HTTP (es. come JSON o XML), anziché risolti come nomi di view. **`@Autowired`**: Permette a Spring di risolvere e iniettare automaticamente le dipendenze di un bean. Può essere applicata a costruttori, setter o campi per far sì che il container IoC fornisca l'istanza corretta della dipendenza richiesta. **`@RequestMapping`**: Mappa le richieste HTTP a metodi specifici di una classe controller. Può essere usata a livello di classe (per un prefisso URL) o a livello di metodo (per specificare il path completo, i metodi HTTP consentiti, i tipi di media prodotti/consumati). Esistono anche le sue varianti specifiche per i metodi HTTP come `@GetMapping`, `@PostMapping`, ecc.",
        keywords: ["@controller", "@restcontroller", "@autowired", "@requestmapping", "spring", "annotazioni", "handler", "di", "mvc", "restful", "@responsebody", "mapping", "http methods"]
    },
    {
        question: "Cos'è un componente Web? E cosa si intende per Web Component?",
        correctAnswer: "Un **componente Web** (con la 'C' minuscola) è un concetto generico che si riferisce a qualsiasi blocco di codice riutilizzabile e incapsulato che costruisce una parte dell'interfaccia utente di una pagina web, tipicamente con HTML, CSS e JavaScript. Può essere un componente di un framework (es. React, Angular, Vue) o un'entità logica. I **Web Components** (con la 'C' maiuscola) sono un insieme di standard W3C nativi del browser che permettono di creare componenti web incapsulati e riutilizzabili indipendentemente da framework. Includono: **Custom Elements**: per definire nuovi tag HTML personalizzati; **Shadow DOM**: per incapsulare lo stile e il markup di un componente, isolandolo dal resto della pagina; **HTML Templates (`<template>` e `<slot>`)**: per definire markup riutilizzabile. Consentono l'interoperabilità tra diversi framework e una maggiore longevità dei componenti.",
        keywords: ["componente web", "web components", "riutilizzabile", "incapsulato", "standard", "custom elements", "shadow dom", "html templates", "w3c", "browser", "interoperabilità"]
    },
    {
        question: "Spiega il funzionamento del ciclo di vita di un componente React o Angular.",
        correctAnswer: "Il ciclo di vita di un componente descrive le diverse fasi attraverso cui passa dalla sua creazione fino alla sua distruzione, offrendo 'hooks' (punti di aggancio) per eseguire codice in momenti specifici. In **React (Class Components)** i metodi includono: `constructor()` (inizializzazione stato), `static getDerivedStateFromProps()` (aggiorna stato dalle props), `render()` (renderizza l'UI), `componentDidMount()` (componente montato nel DOM, per fetching dati), `shouldComponentUpdate()` (ottimizzazione rendering), `componentDidUpdate()` (componente aggiornato), `componentWillUnmount()` (pulizia prima della rimozione). In **Angular (con Lifecycle Hooks)** i principali sono: `ngOnChanges()` (input properties cambiate), `ngOnInit()` (inizializzazione dopo il costruttore, una sola volta), `ngDoCheck()` (rilevamento cambiamenti personalizzato), `ngAfterContentInit()`, `ngAfterContentChecked()`, `ngAfterViewInit()`, `ngAfterViewChecked()` (dopo inizializzazione/controllo di contenuto/view), `ngOnDestroy()` (pulizia prima della distruzione). Entrambi i framework offrono punti per gestire creazione, montaggio, aggiornamento e smontaggio nel DOM.",
        keywords: ["ciclo di vita", "componente", "react", "angular", "montaggio", "aggiornamento", "smontaggio", "hooks", "lifecycle", "ngOnInit", "componentDidMount", "rendering", "dom", "props", "state"]
    },
    {
        question: "Cos'è un Single Page Application (SPA) e quali vantaggi e svantaggi comporta?",
        correctAnswer: "Una Single Page Application (SPA) è un'applicazione web che carica una singola pagina HTML iniziale e aggiorna dinamicamente i contenuti e l'interfaccia utente tramite JavaScript, senza richiedere ricaricamenti completi della pagina dal server ad ogni interazione dell'utente. La navigazione tra le 'viste' avviene manipolando il DOM e usando le API History del browser. **Vantaggi**: 1. **Reattività e User Experience Fluida**: Si avvicina all'esperienza di un'applicazione desktop, riducendo i tempi di attesa. 2. **Minore carico sul server**: Una volta caricata, scambia solo dati (es. JSON) con il backend. 3. **Separazione Frontend/Backend**: Semplifica lo sviluppo e il deployment. **Svantaggi**: 1. **SEO (Search Engine Optimization) più complessa**: I motori di ricerca possono avere difficoltà a indicizzare contenuti generati dinamicamente. 2. **Maggiore carico iniziale**: Richiede il download di più JavaScript e risorse al primo caricamento. 3. **Richiede JavaScript abilitato**: Non funziona se JavaScript è disabilitato nel browser. 4. **Gestione della memoria client-side** può essere più complessa.",
        keywords: ["spa", "single page application", "pagina singola", "javascript", "dinamico", "reattività", "svantaggi", "vantaggi", "seo", "dom", "api history", "user experience", "frontend", "backend"]
    },
    {
        question: "Descrivi i metodi principali del protocollo HTTP (GET, POST, PUT, DELETE) e il loro utilizzo tipico.",
        correctAnswer: "I metodi HTTP, noti anche come 'verbi HTTP', definiscono l'azione che si intende eseguire sulla risorsa identificata dall'URL. Corrispondono tipicamente alle operazioni CRUD (Create, Read, Update, Delete): **`GET`**: Richiede una rappresentazione della risorsa specificata. È idempotente e sicuro (non modifica lo stato del server). Usato per recuperare dati. **`POST`**: Invia dati per creare una nuova risorsa subordinata alla risorsa identificata dall'URI. Non è idempotente. Usato per inviare dati di form, caricare file, o creare nuove entità. **`PUT`**: Sostituisce tutte le rappresentazioni correnti della risorsa di destinazione con il payload della richiesta. È idempotente (ripetere la richiesta produce lo stesso risultato). Usato per aggiornare completamente una risorsa esistente. **`DELETE`**: Rimuove la risorsa specificata. È idempotente. Usato per eliminare una risorsa. Altri metodi includono `PATCH` (aggiornamento parziale) e `HEAD` (solo header della risposta GET).",
        keywords: ["http", "get", "post", "put", "delete", "metodi", "crud", "risorse", "idempotente", "uri", "payload", "sicurezza", "patch", "head"]
    },
    {
        question: "Spiega la differenza tra HTTP e HTTPS.",
        correctAnswer: "HTTP (HyperText Transfer Protocol) è il protocollo standard e non criptato per la trasmissione di dati sul World Wide Web. La comunicazione avviene in chiaro, rendendola vulnerabile a intercettazioni e modifiche. HTTPS (HyperText Transfer Protocol Secure) è la versione sicura di HTTP. Utilizza i protocolli di crittografia SSL (Secure Sockets Layer) o, più comunemente, TLS (Transport Layer Security) per crittografare la comunicazione tra il browser del client e il server web. Questo garantisce **Riservatezza** (i dati sono leggibili solo dal mittente e dal destinatario), **Integrità** (i dati non sono stati alterati durante la trasmissione) e **Autenticazione** (il server è quello dichiarato). È essenziale per qualsiasi scambio di dati sensibili (password, informazioni bancarie) e un fattore di ranking SEO.",
        keywords: ["http", "https", "differenza", "sicurezza", "ssl", "tls", "crittografia", "riservatezza", "integrità", "autenticazione", "web", "dati sensibili", "seo"]
    },
    {
        question: "Cosa sono gli header HTTP e a cosa servono?",
        correctAnswer: "Gli header HTTP sono coppie chiave-valore (es. `Content-Type: application/json`) che vengono inviate sia nelle richieste che nelle risposte HTTP, prima del corpo del messaggio. Contengono metadati essenziali sulla comunicazione, fornendo informazioni aggiuntive al client e al server per interpretare correttamente la richiesta/risposta. Servono a vari scopi: **Controllo della Cache**: `Cache-Control`, `Expires`; **Autenticazione**: `Authorization`, `WWW-Authenticate`; **Tipo di Contenuto**: `Content-Type`, `Content-Length`; **Cookie**: `Set-Cookie`, `Cookie`; **Informazioni sul Client/Server**: `User-Agent`, `Server`; **Negoziazione del Contenuto**: `Accept`, `Accept-Language`. Sono fondamentali per il corretto funzionamento, la sicurezza e l'ottimizzazione delle interazioni web.",
        keywords: ["header http", "metadati", "richieste", "risposte", "chiave-valore", "comunicazione", "cache", "autenticazione", "content-type", "cookie", "user-agent", "sicurezza", "ottimizzazione"]
    },
    {
        question: "Cosa sono i middleware in un'applicazione web e qual è il loro scopo?",
        correctAnswer: "I middleware in un'applicazione web sono funzioni o componenti che intercettano e processano le richieste HTTP in entrata e le risposte HTTP in uscita in una pipeline prima che raggiungano il handler finale. Essenzialmente, agiscono come intermediari tra la richiesta raw del client e la logica di business dell'applicazione. Il loro scopo è aggiungere funzionalità trasversali o 'cross-cutting concerns' in modo modulare e riutilizzabile. Esempi comuni includono: **Logging** (registrare le richieste), **Autenticazione e Autorizzazione** (verificare permessi), **Parsing del body** (JSON, form data), **Gestione errori** (catturare eccezioni), **Compressione**, **Caching**, **CORS**. Permettono di mantenere la logica principale pulita e separare le responsabilità.",
        keywords: ["middleware", "applicazione web", "richieste", "risposte", "intercettano", "processano", "funzionalità trasversali", "logging", "autenticazione", "autorizzazione", "parsing", "gestione errori", "pipeline"]
    },
    {
        question: "Spiega cosa sono le annotazioni e come vengono utilizzate nel contesto Java/Spring.",
        correctAnswer: "Le annotazioni in Java sono una forma di metadati che possono essere aggiunti al codice sorgente. Non alterano direttamente la logica del programma, ma forniscono informazioni al compilatore, agli strumenti di build, ai framework o al runtime JVM. Nel contesto di Spring, le annotazioni sono onnipresenti e fondamentali per la configurazione e la programmazione a basso accoppiamento e dichiarativa. Vengono utilizzate per: **Configurazione di Bean**: `@Component`, `@Service`, `@Repository`, `@Configuration` per definire i bean nel container IoC; **Mapping di richieste Web**: `@RequestMapping`, `@GetMapping`, `@RestController` per definire endpoint REST; **Iniezione di Dipendenze**: `@Autowired`; **Gestione delle Transazioni**: `@Transactional` per definire confini transazionali; **Convalida**: `@NotNull`, `@Size` per validare i dati. Riducono la necessità di configurazioni XML complesse, rendendo il codice più leggibile e conciso.",
        keywords: ["annotazioni", "java", "spring", "metadati", "configurazione", "bean", "request mapping", "di", "transazioni", "validazione", "dichiarativa", "compilatore", "runtime"]
    },
    {
        question: "Cos'è un contesto applicativo (ApplicationContext) in Spring?",
        correctAnswer: "In Spring, l'ApplicationContext è l'interfaccia centrale del container IoC (Inversion of Control). È una versione più avanzata e ricca di funzionalità dell'interfaccia `BeanFactory`. Il suo ruolo principale è quello di istanziare, configurare, assemblare e gestire il ciclo di vita dei 'bean' (gli oggetti gestiti da Spring) dell'applicazione. L'ApplicationContext si occupa di: **Caricare definizioni di bean** (da XML, annotazioni o JavaConfig); **Risolvere le dipendenze** tra i bean tramite Dependency Injection; **Gestire il ciclo di vita** dei bean (inizializzazione, distruzione); **Fornire servizi aggiuntivi** come l'internazionalizzazione (i18n), la pubblicazione di eventi applicativi, la risoluzione di risorse, e l'accesso agli aspetti. Esistono diverse implementazioni a seconda dell'ambiente (es. `ClassPathXmlApplicationContext`, `AnnotationConfigApplicationContext`, `WebApplicationContext`).",
        keywords: ["applicationcontext", "spring", "ioc container", "bean", "ciclo di vita", "configurazione", "dependency injection", "i18n", "eventi", "inversion of control", "scope", "component scan"]
    },

        {
            question: "Descrivi la struttura di un URL e il ruolo di ciascun componente.",
            correctAnswer: "Un URL (Uniform Resource Locator) identifica una risorsa sul web e si compone di: **Protocollo** (es. `http`, `https`) - definisce il metodo di comunicazione. **Host/Dominio** (es. `www.example.com`) - identifica il server ospitante. **Porta** (es. `80`, `443`, spesso omessa per standard) - specifica la porta di rete del server. **Path** (es. `/users/profile`) - indica il percorso della risorsa sul server. **Query String** (es. `?id=123&sort=name`) - parametri passati al server, coppie chiave-valore. **Fragment** (es. `#section`) - un'ancora per una sezione specifica all'interno della risorsa, gestita lato client.",
            keywords: ["url", "uniform resource locator", "struttura url", "protocollo", "host", "dominio", "porta", "path", "query string", "fragment", "risorsa web"]
        },
        {
            question: "Cos'è il DNS (Domain Name System) e qual è il suo ruolo nel funzionamento del web?",
            correctAnswer: "Il DNS (Domain Name System) è un sistema gerarchico e distribuito che traduce i nomi di dominio leggibili dall'uomo (es. `www.google.com`) in indirizzi IP numerici (es. `172.217.160.142`) che i computer utilizzano per identificarsi e comunicare in rete. Il suo ruolo fondamentale nel web è permettere ai browser di trovare il server corretto per il sito web richiesto, agendo come una 'rubrica telefonica' di Internet. Senza DNS, dovremmo ricordare gli indirizzi IP per navigare i siti.",
            keywords: ["dns", "domain name system", "traduzione ip", "nomi di dominio", "indirizzi ip", "server dns", "funzionamento web", "risoluzione nomi"]
        },
        {
            question: "Qual è la differenza tra risorse web statiche e dinamiche? Fornisci esempi.",
            correctAnswer: "Le **risorse statiche** sono file pre-esistenti e non modificati dal server prima di essere inviati al client. Sono gli stessi per ogni richiesta e non richiedono elaborazione lato server (es. file HTML, CSS, JavaScript, immagini, video). Le **risorse dinamiche** sono generate 'al volo' dal server in risposta a una specifica richiesta, spesso coinvolgendo logica di business, accesso a database o dati utente. Variano a seconda della richiesta o dello stato (es. una pagina di profilo utente, i risultati di una ricerca, un'API REST che restituisce JSON).",
            keywords: ["risorse statiche", "risorse dinamiche", "web server", "server-side", "client-side", "elaborazione", "html", "css", "javascript", "immagini", "database", "api rest"]
        },
        {
            question: "Descrivi il ruolo del browser in un'applicazione web, inclusa l'esecuzione di JavaScript.",
            correctAnswer: "Il browser web è il client principale in un'applicazione web. Il suo ruolo include: **Richiedere e ricevere risorse** (HTML, CSS, JS, immagini) dal server tramite HTTP/HTTPS. **Renderizzare la pagina**: Interpretare HTML e CSS per visualizzare la pagina all'utente. **Eseguire JavaScript**: Contiene un motore JavaScript (es. V8 per Chrome) che esegue il codice JavaScript lato client, rendendo le pagine interattive, manipolando il DOM e gestendo operazioni asincrone. **Gestione eventi**: Rileva e gestisce eventi utente (click, input) ed eventi di rete (risposte HTTP). **Gestione della cache**: Memorizza risorse per velocizzare i caricamenti futuri. È l'interfaccia principale attraverso cui l'utente interagisce con l'applicazione web.",
            keywords: ["browser", "client web", "renderizzare", "motore javascript", "esecuzione javascript", "dom", "eventi", "cache", "interazione utente", "http", "https"]
        },
        {
            question: "Descrivi le fasi principali di una transazione HTTP completa, dalla richiesta all'arrivo della risposta nel browser.",
            correctAnswer: "Una transazione HTTP tipica si svolge in queste fasi: 1. **Input URL**: L'utente digita un URL nel browser o clicca un link. 2. **Risoluzione DNS**: Il browser interroga il DNS per ottenere l'indirizzo IP del server corrispondente al nome di dominio. 3. **Connessione TCP**: Il browser stabilisce una connessione TCP/IP con il server all'indirizzo IP ottenuto. 4. **Invio Richiesta HTTP**: Il browser invia la richiesta HTTP (es. GET /index.html) al server, inclusi header e body (se presenti). 5. **Elaborazione Server**: Il server riceve la richiesta, la processa (potrebbe coinvolgere logica applicativa, database), e genera una risposta. 6. **Invio Risposta HTTP**: Il server invia la risposta HTTP (con status code, header, body) al browser. 7. **Rendering Browser**: Il browser riceve la risposta, interpreta i contenuti (HTML, CSS), esegue JavaScript e visualizza la pagina all'utente. 8. **Chiusura/Mantenimento Connessione**: La connessione TCP può essere chiusa o mantenuta per richieste future (persistent connection).",
            keywords: ["transazione http", "fasi http", "richiesta http", "risposta http", "url", "dns", "connessione tcp", "elaborazione server", "rendering browser", "http headers", "status codes"]
        },
        {
            question: "Spiega l'importanza degli status code HTTP in una risposta del server e fornisci esempi delle categorie principali.",
            correctAnswer: "Gli status code HTTP sono codici numerici a tre cifre inclusi nella prima riga della risposta HTTP del server. Indicano l'esito della richiesta fatta dal client e il tipo di risposta fornita. Sono cruciali per il client per capire se la richiesta ha avuto successo, se ci sono stati errori, o se sono necessarie ulteriori azioni. Le categorie principali sono: **1xx (Informational)**: La richiesta è stata ricevuta e il processo continua. **2xx (Success)**: La richiesta è stata ricevuta, compresa e accettata con successo (es. `200 OK`, `201 Created`, `204 No Content`). **3xx (Redirection)**: Il client deve intraprendere ulteriori azioni per completare la richiesta (es. `301 Moved Permanently`, `302 Found`). **4xx (Client Error)**: La richiesta contiene una sintassi errata o non può essere soddisfatta (es. `400 Bad Request`, `401 Unauthorized`, `403 Forbidden`, `404 Not Found`). **5xx (Server Error)**: Il server non è riuscito a soddisfare una richiesta apparentemente valida (es. `500 Internal Server Error`, `503 Service Unavailable`).",
            keywords: ["status code http", "codici di stato", "risposta http", "esito richiesta", "1xx", "2xx", "3xx", "4xx", "5xx", "successo", "errore client", "errore server", "redirect", "http"]
        },
        {
            question: "Qual è il significato dei MIME type negli header HTTP?",
            correctAnswer: "I MIME type (Multipurpose Internet Mail Extensions), specificati nell'header HTTP `Content-Type` sia nelle richieste che nelle risposte, indicano la natura e il formato del documento o del file trasmesso. Sono stringhe composte da un tipo di media e un sottotipo (es. `text/html`, `application/json`, `image/jpeg`). Il loro significato è cruciale perché permettono al browser (o ad altri client) di capire come interpretare e renderizzare correttamente il contenuto ricevuto. Senza il MIME type corretto, il browser potrebbe non visualizzare correttamente il file, tentare di scaricarlo o mostrare un errore.",
            keywords: ["mime type", "content-type", "header http", "formato file", "tipo media", "sottotipo", "interpretazione browser", "html", "json", "jpeg", "comunicazione web"]
        },
        {
            question: "Spiega brevemente il concetto di full-stack web application e come interagiscono le sue parti.",
            correctAnswer: "Una full-stack web application è un'applicazione che gestisce sia il **frontend** (lato client, l'interfaccia utente con cui l'utente interagisce, sviluppato con HTML, CSS, JavaScript) che il **backend** (lato server, la logica di business e la gestione dei dati, sviluppato con linguaggi come Java, Python, Node.js, PHP, e interagendo con un database). Le due parti interagiscono principalmente tramite **API** (solitamente RESTful) su HTTP/HTTPS. Il frontend invia richieste HTTP al backend per ottenere, creare, aggiornare o eliminare dati. Il backend elabora queste richieste, interagisce con il database se necessario, e restituisce una risposta (spesso JSON) al frontend, che poi aggiorna dinamicamente l'interfaccia utente. Questo modello permette una chiara separazione delle responsabilità e scalabilità.",
            keywords: ["full-stack", "frontend", "backend", "lato client", "lato server", "api", "restful", "http", "database", "interazione", "html", "css", "javascript", "logica di business", "scalabilità"]
        },
        {
            question: "Cosa si intende per 'sessione' in un'applicazione web e a cosa serve?",
            correctAnswer: "Una 'sessione' in un'applicazione web è un meccanismo utilizzato dal server per mantenere uno stato persistente tra diverse richieste HTTP dello stesso utente. Poiché HTTP è un protocollo stateless, ogni richiesta è indipendente. La sessione serve a 'ricordare' l'utente e i suoi dati (es. stato di login, preferenze, carrello acquisti) attraverso le varie interazioni con l'applicazione. Tipicamente, quando un utente si autentica, il server crea una sessione e le assegna un ID unico (session ID), che viene poi inviato al browser (spesso tramite un cookie). Per le richieste successive, il browser invia l'ID della sessione, permettendo al server di recuperare lo stato associato a quell'utente. Questo è fondamentale per esperienze utente personalizzate e persistenti.",
            keywords: ["sessione", "session id", "stateless", "http", "stato utente", "autenticazione", "cookie", "persistency", "server-side", "gestione stato"]
        },
        {
            question: "Spiega il concetto di filtri (o interceptor) in un contesto server-side (es. Java Servlets, Spring) per la sicurezza e la logica trasversale.",
            correctAnswer: "I filtri (chiamati a volte interceptor in alcuni framework come Spring) in un contesto server-side sono componenti che intercettano le richieste in ingresso e/o le risposte in uscita prima che raggiungano il loro handler finale (es. una Servlet o un controller REST). Agiscono come 'middleware' sul lato server e permettono di applicare logiche trasversali (cross-cutting concerns) in modo modulare. Vengono utilizzati per: **Sicurezza**: Autenticazione (es. verifica credenziali) e Autorizzazione (verifica permessi); **Logging**: Registrare informazioni sulle richieste; **Compressione/Crittografia**: Modificare il corpo della richiesta/risposta; **Validazione**: Controllare i dati in ingresso. In Java Servlets si implementa l'interfaccia `Filter` e si configura nel `web.xml` o con annotazioni; in Spring, si usano principalmente gli interceptor del framework MVC o AOP.",
            keywords: ["filtri", "interceptor", "server-side", "servlet", "spring", "sicurezza", "logging", "autenticazione", "autorizzazione", "logica trasversale", "middleware", "richieste", "risposte"]
        },
    {
        question: "Cosa fa il DNS e qual è il suo ruolo in una richiesta HTTP?",
        correctAnswer: "Il DNS (Domain Name System) è un servizio che traduce il nome di dominio leggibile (es. www.example.com) nell'indirizzo IP corrispondente necessario per comunicare con il Web Server. Quando il client vuole inviare una richiesta HTTP, prima consulta un DNS server per ottenere l'IP dell'host indicato nella URL. Solo dopo questa risoluzione il browser può inviare la richiesta al server giusto.",
        keywords: ["dns", "domain name system", "indirizzo ip", "risoluzione", "host", "http", "browser"]
    },
    {
        question: "Quali sono le componenti principali di una URL e cosa rappresentano?",
        correctAnswer: "Una URL (Uniform Resource Locator) identifica univocamente una risorsa nel Web e ha una struttura composta da: protocollo (es. http, https), hostname (dominio del server), porta (opzionale), path (percorso alla risorsa), query string (parametri opzionali), fragment (punto interno nella risorsa, es. sezione di una pagina HTML). Ogni componente contribuisce a localizzare e interagire con una risorsa specifica.",
        keywords: ["url", "protocollo", "hostname", "path", "query string", "fragment", "porta", "risorsa"]
    },
    {
        question: "Cosa sono i MIME types e perché sono importanti nelle richieste e risposte HTTP?",
        correctAnswer: "I MIME types (Multipurpose Internet Mail Extensions) specificano il tipo di contenuto trasmesso in una richiesta o risposta HTTP. Servono a comunicare al browser o server come interpretare il corpo del messaggio. Esempi comuni: 'text/html' per pagine web, 'application/json' per dati strutturati, 'image/jpeg' per immagini. Sono fondamentali per il corretto funzionamento delle applicazioni web.",
        keywords: ["mime", "content-type", "http", "tipi di contenuto", "html", "json", "image", "browser"]
    },
    {
        question: "Qual è la differenza tra una risorsa statica e una dinamica in un'applicazione web?",
        correctAnswer: "Una risorsa statica è un file preesistente sul server (es. HTML, CSS, immagini) che viene restituito così com'è al client. Una risorsa dinamica viene generata al momento da uno script o programma lato server, spesso basandosi su dati della richiesta. Le risorse dinamiche permettono di creare contenuti personalizzati e interattivi, come pagine con dati utente o risultati di ricerche.",
        keywords: ["statica", "dinamica", "risorsa", "server", "http", "html", "script", "contenuto", "personalizzato"]
    },
    {
        question: "Come può un'applicazione lato server essere implementata in diversi linguaggi?",
        correctAnswer: "Un'applicazione lato server può essere scritta in vari linguaggi (JavaScript, Java, Python, PHP, ecc.) purché il Web Server supporti l'esecuzione di quel linguaggio, tramite estensioni o runtime specifici. Ad esempio, Node.js per JavaScript, Tomcat per Java, o Apache/PHP. La scelta del linguaggio dipende da fattori come prestazioni, ecosistema, o competenze del team.",
        keywords: ["server-side", "linguaggi", "node.js", "java", "php", "python", "web server", "applicazione"]
    },
    {
        question: "Cos'è il localStorage in JavaScript e quando viene usato?",
        correctAnswer: "Il localStorage è una Web API che permette di memorizzare dati persistenti nel browser in forma chiave/valore, accessibili anche dopo la chiusura della scheda o del browser. Viene usato per salvare preferenze utente, token di autenticazione o stato dell'applicazione lato client, senza necessità di interazioni con il server. È soggetto alla Same-Origin Policy.",
        keywords: ["localstorage", "memoria", "browser", "javascript", "persistente", "dati", "stato", "client", "web api"]
    }


];